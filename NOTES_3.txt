#! Setting Up the Project and Database
1. Open MySQL Workbench and create a new database named storefront3.
2. Run "python manage.py makemigrations" and "python manage.py migrate" to create the tables in the database.
3. Now rather than using the seed.sql directly to import the data in the database using the SQL Workbench, we will use a custom command.
4. Create a custom command named "seed_db" my creating a management folder followed by a commands folder inside the store app. 
5. Write the following code in seed_db.py and place seed.sql file in the same directory.
"
#! CUSTOM COMMAND TO POPULATE THE DATABASE
from django.core.management.base import BaseCommand
from django.db import connection
from pathlib import Path
import os


class Command(BaseCommand):
    help = 'Populates the database with collections and products'

    def handle(self, *args, **options):
        print('Populating the database...')
        current_dir = os.path.dirname(__file__)
        file_path = os.path.join(current_dir, 'seed.sql')
        sql = Path(file_path).read_text()

        with connection.cursor() as cursor:
            cursor.execute(sql)

"
6. Now in the terminal, just type "python manage.py", we will see this output::
"
(venv) PS D:\Ultimate-Django-Series\Ultimate Django Series 3> python .\manage.py

Type 'manage.py help <subcommand>' for help on a specific subcommand.

Available subcommands:

[auth]
    changepassword
    createsuperuser

[contenttypes]
    remove_stale_contenttypes

[debug_toolbar]
    debugsqlshell

[django]
    check
    compilemessages
    createcachetable
    dbshell
    diffsettings
    flush
    inspectdb
    loaddata
    makemessages
    makemigrations
    migrate
    optimizemigration
    sendtestemail
    shell
    showmigrations
    sqlflush
    sqlmigrate
    sqlsequencereset
    squashmigrations
    startapp
    startproject
    test
    testserver

[rest_framework]
    generateschema

[sessions]
    clearsessions

[staticfiles]
    collectstatic
    findstatic
    runserver

[store]
    seed_db
"
7. Now run the "python manage.py seed_db" command to populate the database.

#* Overview
1. Uploading Files
2. Sending emails
3. Running Background Tasks
4. Automated testing
5. Performance testing
6. Caching, etc.

#* Section - 1 (Uploading Files)

#! Managing Media Files 
1. Create a "media" folder in the root directory of the project.
2. Imsert any image in the media folder.
3. Add MEDIA_URL and MEDIA_ROOT to settings.py.
"
MEDIA_URL = '/media/'
# MEDIA_ROOT = BASE_DIR / 'media'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
"
4. Add these to urls.py of the project directory.
"
from django.conf import settings
from django.conf.urls.static import static
from django.contrib import admin
from django.urls import path, include
import debug_toolbar

admin.site.site_header = "Storefront Admin"
admin.site.index_title = "Admin"

urlpatterns = [
    path("admin/", admin.site.urls),
    path("playground/", include("playground.urls")),
    path("store/", include("store.urls")),
    path("auth/", include("djoser.urls")),
    path("auth/", include("djoser.urls.jwt")),
    path("__debug__/", include(debug_toolbar.urls)),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
"
5. Now go to "127.0.0.1:8000/media/{image.png}" and you will see the image in the browser. 

#! Adding Images to Products
1. Create a fact table for Product table which will be a one to many relationship (Product)(1) -> (Image)(n)
2. Add the following model in models.py
"
class ProductImage(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(upload_to='store/images', blank=True, null=True)
"
#! Building an API to Upload Images 
1. Now we will create a API with url like "/products/1/images/1"
Step-1: Create a serializer
Step-2: Create a viewset
Step-3: Create a router

** serializers.py
"
class ProductImageSerializer(serializers.ModelSerializer):
    def create(self, validated_data):
        product_id = self.context['product_id']
        return ProductImage.objects.create(product_id=product_id, **validated_data)
    class Meta:
        model = ProductImage
        fields = ['id', 'image']
"
** views.py
"
class ProductImageViewSet(ModelViewSet):
    serializer_class = ProductImageSerializer
    # queryset = ProductImage.objects.all()
    
    def get_serializer_context(self):
        return {'product_id': self.kwargs['product_pk']}
    
    #! URL like "/products/1(product_pk)/images/1(pk)"
    def get_queryset(self):
        return ProductImage.objects.filter(product_id=self.kwargs['product_pk'])
"
** urls.py
"
products_router.register('images', views.ProductImageViewSet, basename='product-images')
"

Now the urlpatterns looks like this:
"
[<URLPattern '^products/$' [name='products-list']>,
 <URLPattern '^products\.(?P<format>[a-z0-9]+)/?$' [name='products-list']>,
 <URLPattern '^products/(?P<pk>[^/.]+)/$' [name='products-detail']>,
 <URLPattern '^products/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='products-detail']>,
 <URLPattern '^collections/$' [name='collection-list']>,
 <URLPattern '^collections\.(?P<format>[a-z0-9]+)/?$' [name='collection-list']>,
 <URLPattern '^collections/(?P<pk>[^/.]+)/$' [name='collection-detail']>,
 <URLPattern '^collections/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='collection-detail']>,
 <URLPattern '^carts/$' [name='cart-list']>,
 <URLPattern '^carts\.(?P<format>[a-z0-9]+)/?$' [name='cart-list']>,
 <URLPattern '^carts/(?P<pk>[^/.]+)/$' [name='cart-detail']>,
 <URLPattern '^carts/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='cart-detail']>,
 <URLPattern '^customers/$' [name='customer-list']>,
 <URLPattern '^customers\.(?P<format>[a-z0-9]+)/?$' [name='customer-list']>,
 <URLPattern '^customers/me/$' [name='customer-me']>,
 <URLPattern '^customers/me\.(?P<format>[a-z0-9]+)/?$' [name='customer-me']>,
 <URLPattern '^customers/(?P<pk>[^/.]+)/$' [name='customer-detail']>,
 <URLPattern '^customers/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='customer-detail']>,
 <URLPattern '^customers/(?P<pk>[^/.]+)/history/$' [name='customer-history']>,
 <URLPattern '^customers/(?P<pk>[^/.]+)/history\.(?P<format>[a-z0-9]+)/?$' [name='customer-history']>,
 <URLPattern '^orders/$' [name='orders-list']>,
 <URLPattern '^orders\.(?P<format>[a-z0-9]+)/?$' [name='orders-list']>,
 <URLPattern '^orders/(?P<pk>[^/.]+)/$' [name='orders-detail']>,
 <URLPattern '^orders/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='orders-detail']>,
 <URLPattern '' [name='api-root']>,
 <URLPattern '<drf_format_suffix:format>' [name='api-root']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/reviews/$' [name='product-reviews-list']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/reviews\.(?P<format>[a-z0-9]+)/?$' [name='product-reviews-list']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/reviews/(?P<pk>[^/.]+)/$' [name='product-reviews-detail']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/reviews/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='product-reviews-detail']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/images/$' [name='product-images-list']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/images\.(?P<format>[a-z0-9]+)/?$' [name='product-images-list']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/images/(?P<pk>[^/.]+)/$' [name='product-images-detail']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/images/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='product-images-detail']>,
 <URLPattern '' [name='api-root']>,
 <URLPattern '<drf_format_suffix:format>' [name='api-root']>,
 <URLPattern '^carts/(?P<cart_pk>[^/.]+)/items/$' [name='cart-items-list']>,
 <URLPattern '^carts/(?P<cart_pk>[^/.]+)/items\.(?P<format>[a-z0-9]+)/?$' [name='cart-items-list']>,
 <URLPattern '^carts/(?P<cart_pk>[^/.]+)/items/(?P<pk>[^/.]+)/$' [name='cart-items-detail']>,
 <URLPattern '^carts/(?P<cart_pk>[^/.]+)/items/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='cart-items-detail']>,
 <URLPattern '' [name='api-root']>,
 <URLPattern '<drf_format_suffix:format>' [name='api-root']>]
"

#! Returning Images from the Product API
1. We need images to be returned in the Product API
2. Add images to the ProductSerializer
** serializer.py
"
class ProductImageSerializer(serializers.ModelSerializer):
    def create(self, validated_data):
        product_id = self.context['product_id']
        return ProductImage.objects.create(product_id=product_id, **validated_data)
    class Meta:
        model = ProductImage
        fields = ['id', 'image']

class ProductSerializer(serializers.ModelSerializer):
    images = ProductImageSerializer(many=True, read_only=True)
    class Meta:
        model = Product
        fields = ['id', 'title', 'description', 'slug', 'inventory',
                  'unit_price', 'price_with_tax', 'collection', 'images']

    price_with_tax = serializers.SerializerMethodField(
        method_name='calculate_tax')

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
" 
3. Now we can get these images but there are lots of duplicate sql queries, so we need to get the related fields beforehand.
** select_related is best used for "one-to-one" or "many-to-one" relationships.
** prefetch_related, on the other hand, is designed for "one-to-many" and "many-to-many" relationships.

Since we have one to many relationships, we will use prefetch_related.
** views.py
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.prefetch_related('images').all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    permission_classes = [IsAdminOrReadOnly]
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)

        return super().destroy(request, *args, **kwargs)
"

#! JWT Tokens for Authentication
{
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcyMDg4NTU0MiwiaWF0IjoxNzIwNzk5MTQyLCJqdGkiOiJlNWIwNmIzOTE0Yzc0YzE4OGM2ZDUzMzJlYjhjNzUyMyIsInVzZXJfaWQiOjF9.dsdTcrHVk6mUUycWxDgq_Vkxd4jc5zi4n9sw5vUITLM",
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzI5NDM5MTQyLCJpYXQiOjE3MjA3OTkxNDIsImp0aSI6ImNhNjU3ZTNhNmY5NjQyY2Y4YzFhZjJjZTIzMmM5ZTZlIiwidXNlcl9pZCI6MX0.KzA1Cs99loTmmm1xNx8mReiPhj5-NSfhN7a1Y9TdKzc"
}

Then add "JWT <access_token>" in your ModHeader Chrome extension. Now you can access all the protected routes.

#! Validating uploaded files
1. Create a file called "validators.py" in the "store" app
** validators.py
"
from django.core.exceptions import ValidationError

def validate_file_size(file):
    max_size_kb = 50
    
    if file.size > max_size_kb * 1024:
        raise ValidationError(f'File size should not exceed {max_size_kb} KB')
"

Now add this validator in the ProductImage model
** models.py
"
class ProductImage(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(upload_to='store/images', blank=True, null=True, validators=[validate_file_size])
"

#! Setting Up the Client App
I have uploaded the storefront3_client folder in the root directory of the project.
* Check your node version with "node -v"
* Install the dependencies with "npm install"
* Start the development server with "npm start"

#! Enabling CORS 
1. When we try to upload image from the frontend, we get error: "Could not reach the server!"
2. This is a classic CORS (Cross-Origin Resource Sharing) error.
3. This policy prevents any app hosted in domain1 to send request to apps hosted in domain2.
4. Here we are facing this issue because the client app is hosted in domain1 (8001) and the server is hosted in domain2 (8000).

5. To solve this CORS problem, we need to change some settings from the server side to allow requests from domain1 (8001).
6. We will use django python package "django-cors-headers"
Step-1: "pip install django-cors-headers"
Step-2: Add it to INSTALLED_APPS in settings.py "corsheaders"
Step-3: Add it to MIDDLEWARE in settings.py "corsheaders.middleware.CorsMiddleware"
Step-4: Add it to settings.py "CORS_ALLOWED_ORIGINS"
"
CORS_ALLOWED_ORIGINS = [
    'http://localhost:8001',
    'http://127.0.0.1:8001',
]
"

#! Managing Images in the Admin 
** media/store/styles.css 
"
.thumbnail {
    width: 100px;
    height: 100px;
    object-fit: cover;
}
"

** store/admin.py
"
class ProductImageInline(admin.TabularInline):
    model = models.ProductImage
    readonly_fields = ['thumbnail']

    def thumbnail(self, instance):
        if instance.image.name != '':
            return format_html(f'<img src="{instance.image.url}" class="thumbnail" />')
        return ''
"

** core/admin.py
"
class CustomProductAdmin(ProductAdmin):
    inlines = [TagInline, ProductImageInline]
"

#* Section - 2 (Sending Email)

#! Setting Up a fake SMTP server
1. SMTP -> Simple Mail Transfer Protocol
2. For setting up a fake SMTP server, we will use "https://github.com/rnwood/smtp4dev"
3. Check its installation page, and then we will clone the fake server using docker image 
4. run "docker run --rm -it -p 5000:80 -p 2525:25 rnwood/smtp4dev"
We will get this output:
"
PS C:\Users\CZ0258> docker run --rm -it -p 5000:80 -p 2525:25 rnwood/smtp4dev
Unable to find image 'rnwood/smtp4dev:latest' locally
latest: Pulling from rnwood/smtp4dev
09f376ebb190: Pull complete
7248743022af: Pull complete
95fcf2c5436c: Pull complete
0fbaf16568f1: Pull complete
e9e190cbc518: Pull complete
a893f927642d: Pull complete
25f219cce78d: Pull complete
Digest: sha256:912304153668068188d83b612fe0b7c4ec852dddb45fb2946895c7a72e89c6f2
Status: Downloaded newer image for rnwood/smtp4dev:latest
smtp4dev version 3.6.1+5e577a8b4152ceb7276a5b8d4432430c9ff9055d
https://github.com/rnwood/smtp4dev
.NET Core runtime version: .NET 8.0.4

 > For help use argument --help

Install location: /
DataDir: /smtp4dev
Default settings file: /app/appsettings.json
User settings file: /smtp4dev/appsettings.json
Storing keys in a directory '/root/.aspnet/DataProtection-Keys' that may not be persisted outside of the container. Protected data will be unavailable when container is destroyed. For more information go to https://aka.ms/aspnet/dataprotectionwarning
Parsing AutomaticRelayExpression
Parsing CredentialsValidationExpression
Parsing RecipientValidationExpression
Parsing MessageValidationExpression
No XML encryptor configured. Key {2276da35-cd42-4491-96d2-c05821926287} may be persisted to storage in unencrypted form.
Using Sqlite database at /smtp4dev/database.db
Updating DB schema with migrations: 20181020095712_InitialCreate, 20181021072518_AddSessionToMessageReln, 20181021105259_AddSessionStartData, 20181022132948_AddSessionErrorInfo, 20181022163054_AddAttachmentCount, 20190310130227_AddMessageUnreadFlag, 20200904135503_AddRelayError, 20200924120747_AddImapState, 20210211134331_AddMessageSecurity, 20210731045851_UTCTimeMigration, 20210807032903_MessageRelay, 20210901140449_Fix_Messages_PK, 20240308081358_AddSessionEncoding, 20240309084542_AddMessageEightBitTransport, 20240425190525_AddMailboxes, 20240511110456_AddDeliveredTo, 20240515191815_FixSessionMessageCascasing
Creating mailbox Default
TLS mode: None
SMTP Server is listening on port 25 (::).
Keeping last 100 messages per mailbox and 100 sessions.
IMAP Server is listening on port 143 (::)
Overriding HTTP_PORTS '80' and HTTPS_PORTS ''. Binding to values defined by URLS instead 'http://*:80'.
Now listening on: http://[::]:80
"
5. Now since the server is running on port 5000, we will use "http://localhost:5000" to send an email.

#! Configuring the email backend
There are various types of backends:
* SMTP (default)
* Console
* File
* Locmmem
* Dummy

1. Add the following code in settings.py
"
# EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
# EMAIL_BACKEND = 'django.core.mail.filebased.console.EmailBackend'
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'localhost'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 2525 # Check your email server terminal input command and output from NOTES_3.txt
DEFAULT_FROM_EMAIL = 'from@example.com'
"

#! Sending Emails
1. We can send mail using send_mail and mail_admins
2. We do not need to add any configuration for send_mail but for mail_admins we need to add the following code:
"
ADMINS = [
    ('admin', 'admin@gmail.com'),
]
"
3. Go to playground/views.py
"
from django.core.mail import send_mail, mail_admins, BadHeaderError
from django.shortcuts import render

def say_hello(request):
    try:
        # send_mail(subject="Django Test Email", message="Hello, this is a test email from django smtp server...", from_email="ayushdjango@gmail.com", recipient_list=["ayushsenapati123@gmail.com"])
        mail_admins(subject="Django Test Email", message="Hello, this is a test email from django smtp server...", fail_silently=False, html_message="Hello, this is a test email from django smtp server...")
    except BadHeaderError:
        pass
    return render(request, 'hello.html', {'name': 'Ayush Senapati'})
"

#! Attaching files
1. We will use EmailMessage for attaching files
** playground/views.py
"
from django.core.mail import send_mail, mail_admins, BadHeaderError, EmailMessage
from django.shortcuts import render


def say_hello(request):
    try:
        message = EmailMessage(
            subject="Django Test Email",
            body="Hello, this is a test email from django smtp server...",
            from_email="ayushdjango@gmail.com",
            to=["ayushsenapati123@gmail.com"],
        )
        message.attach_file("playground/static/images/amazon.png")
        message.send()
    except BadHeaderError:
        pass

    return render(request, "hello.html", {"name": "Ayush Senapati"})

"

#! Sending Templated Emails
1. "pip install django-templated-mail"
2. Create a new template in playground/templates/email/hello.html
"
{% block subject %}This is a long subject{% endblock %}

{% block html_body %}
<h1>Hello</h1>
My name is {{ name }}
{% endblock %}
"
3. In playground/views.py
"
from django.core.mail import EmailMessage, BadHeaderError
from django.shortcuts import render
from templated_mail.mail import BaseEmailMessage


def say_hello(request):
    try:
       message = BaseEmailMessage(
           template_name='emails/hello.html',
           context={'name': 'Ayush'}
       )
       message.send(['ayushsenapati123@gmail.com'])
    except BadHeaderError:
        pass
    return render(request, 'hello.html', {'name': 'Ayush Senapati'})
"

#* Section - 3 (Running Background Tasks)

#! Introduction to Celery

1. There are lots of long-running tasks like:
* Sending Emails
* Processing images and videos
* Generating reports
* Running machine learning models, etc.

2. With celery, we can have multiple workers working in parallel for our application.
3. Flow:
Application -> Queue -> Worker_1, Worker_2, Worker_3, etc
4. The main advantage of using Celery is that:
* we can schedule tasks to be run in the future i.e periodic tasks.
* time taking tasks can be run in the background.
* even if any worker goes down, tasks can still be run and the main application will not be blocked.

#! Message Broker
1. Flow:
Application -> Queue -> Worker_1, Worker_2, Worker_3, etc
2. Here the queue is the message broker responsible for assigning tasks along with sending and receiving messages from the workers.
3. Broker is just the middleman between the application and the workers.
4. Celery provides message broker like:
* Redis (in-memory data store)
* RabbitMQ (real, enterprise-grade broker)
5. We will use redis as our cache + message broker

#! Installing Redis
1. Here, we will use docker to install and use redis.
2. Redis will be inside a docker container which you can think of as a isolated light weight virtual machine.
3. Our application and the redis in the container will communicate using a port.
4. Use "docker run -d -p 6379:6379 redis" to run the container.
The command "docker run -d -p 6379:6379 redis" is used to start a new Docker container based on the redis image. Let's break down each part of the command to understand what it does:

** docker run: This is the basic command used to create and start a new container from an image.
** -d: The -d flag stands for "detached mode." When you run a container in detached mode, it starts in the background and doesn't receive input or display output in your terminal. This allows you to continue using the terminal while the container runs.
** -p 6379:6379: The -p flag is used to publish a container's port(s) to the host (your computer). The syntax is -p <host_port>:<container_port>. In this case, 6379:6379 means that port 6379 inside the container (the standard port for Redis) is mapped to port 6379 on your host machine. This allows you to connect to the Redis instance running inside the Docker container from any application running on your host machine that needs to communicate with Redis.
** redis: Finally, redis specifies the name of the Docker image to use when creating the container. Docker images contain the software needed to run applications. In this case, redis refers to the official Redis image available on Docker Hub, which includes the Redis server.
5. Use "docker ps" to check all the containers which are running.
"
PS D:\Ultimate-Django-Series> docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS              PORTS                    NAMES
d4f0c5014983   redis     "docker-entrypoint.sâ€¦"   About a minute ago   Up About a minute   0.0.0.0:6379->6379/tcp   laughing_mirzakhani
"
6. Also install redis as your django dependency by running: "pip install redis"

#! Celery and Windows
1. Celery 4+ and above are not supported on Windows.
2. To solve this, we will use WSL i.e Windows Subsystem for Linux.

#! Setting up Celery
1. Run "pip install celery"
2. Inside the project directory, create a new file named celery.py
** storefront/celery.py
"
import os
from celery import Celery

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'storefront.settings')

celery = Celery('storefront')
celery.config_from_object('django.conf:settings', namespace='CELERY')
celery.autodiscover_tasks()   
"
3. But for django to recognize this celery.py code, add it to __init__.py
"
from storefront.celery import celery
"
4. Add this to settings.py
** storefront/settings.py
"
# CELERY_BROKER_URL = 'redis://127.0.0.1:6379'
CELERY_BROKER_URL = 'redis://localhost:6379/1'
"

5. So, currently we need 3 commands for our application to run:
-> python manage.py runserver
-> docker run -p 6379:6379 redis
-> celery -A storefront worker --loglevel=info
6. This is where docker can be very helpful. We will use "docker-compose up" to do this. This will be implemented at the end of this project development.

#! Creating and Executing Tasks
1. Create a new file named tasks.py
** storefront/tasks.py
"
from time import sleep
from celery import shared_task

@shared_task
def notify_customers(message):
    print("Sending 10k emails to customers...")
    print(message)
    sleep(10)
    print("Emails were successfully sent!!!")
"

** storefront/views.py
"
from django.shortcuts import render
from playground.tasks import notify_customers

def say_hello(request):
    notify_customers.delay(message="Hello World")
    return render(request, 'hello.html', {'name': 'Ayush Senapati'})
"

#! Scheduling Periodic Tasks
1. Used for:
* Generating periodic tasks
* Sending emails
* Running maintenance tasks
2. We will use "celery beat" to schedule periodic tasks
3. pip install django-celery-beat
4. Add it to INSTALLED_APPS in settings.py => "django_celery_beat"
5. Add the following code to settings.py
"
CELERY_BEAT_SCHEDULE = {
    #! For better consistency, it is better to use same name as in tasks.py
    'notify_customers': {
        'task': 'playground.tasks.notify_customers',
        'schedule': 5, #! Schedule interval in seconds
        'args': ['Hello World']
    }
}
"
6. Use "celery -A storefront beat --loglevel=info" to start the celery beat
7. Use "celery -A storefront worker --loglevel=info" to start the celery worker
8. Now beat will send the periodic tasks to the worker every 5 seconds.

#! Monitoring Celery Tasks
1. For monitoring, we will use flower => pip install flower
2. Use "celery -A storefront flower"
3. Open http://localhost:5555 in your browser

4. We can also use django-celery-result => pip install django-celery-results
5. Add it to INSTALLED_APPS in settings.py => "django_celery_results"
6. Add the following code to settings.py
"
CELERY_RESULT_BACKEND = 'django-db'
"

#TODO => Major Changes
# ! Updated Celery Configuration 
** storefront/settings.py
"
CELERY_BROKER_URL = 'redis://127.0.0.1:6379' #! 6379 is the default port.
CELERY_ACCEPT_CONTENT = ['application/json']
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TASK_SERIALIZER = 'json'

CELERY_RESULT_BACKEND = 'django-db'

CELERY_BEAT_SCHEDULE = {
    #! For better consistency, it is better to use same name as in tasks.py
    'notify_customers': {
        'task': 'playground.tasks.notify_customers',
        'schedule': 5, #! Schedule interval in seconds
        'args': ['Hello World']
    }
}
"

** storefront/celery.py
"
import os
from celery import Celery
from django.conf import settings

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'storefront.settings')

celery = Celery('storefront')
celery.config_from_object(settings, namespace='CELERY')
celery.autodiscover_tasks()
"

** storefront/__init__.py
"
from storefront.celery import celery as celery_app

__all__ = ('celery_app',)
"

** playground/tasks.py
"
from time import sleep
from celery import shared_task


@shared_task(bind=True)
def test_func(self):
    # operations
    for i in range(10):
        print(i)
    return "Done"


@shared_task
def notify_customers(message):
    print("Sending 10k emails to customers...")
    print(message)
    sleep(10)
    print("Emails were successfully sent!!!")

"

** playground/views.py
"
from django.shortcuts import render
from playground.tasks import notify_customers


def say_hello(request):
    notify_customers.delay(message="Hello World")
    return render(request, 'hello.html', {'name': 'Ayush Senapati'})
"

1. Run command for worker => "celery -A storefront.celery worker --pool=solo --loglevel=info"
2. Run command for beat => "celery -A storefront.celery beat --loglevel=info"
3. Run command for flower => "celery -A storefront.celery flower"

#* Section - 4 (Automated Testing)

#! What is Automated Testing?
Automated Testing is a process of writing automated tests for your software. Manual testing is possible but as our application grows with time, manual testing will not be feasible anymore so we use automated testing.

#! Test Behaviours, Not Implementations 
1. While testing, just test the behaviour, not the implementation.
2. We check whether the fan is on or off by checking the rotation speed of the fan rather than opening the fan and checking the input and output current from the capacitors and rotors.
3. Watch the video once for some more details.

#! Tooling ( Test Frameworks )
1. Pytest (we will use this)
2. unittest

* pip install pytest
* pip install pytest-django (This is a django dependency for pytest)

#! First Test
1. Create a new folder called "tests" inside "store" directory. This folder convention is a must.
2. Inside the tests folder, create a new file named "test_collections.py". This "test_" convention is a must.
3. Create a new function inside the file named "test_collections.py". This "test_" function convention is a must.
"
from rest_framework import status
from rest_framework.test import APIClient

class TestCreateCollection():
    def test_if_user_is_anonymous_return_401(self):
        #TODO => Format for any test => AAA (Arrange, Act, Assert)
        # Arrange
        
        # Act
        client = APIClient()
        response = client.post('/store/collections/', {'title': 'some title'})
        
        # Assert
        assert response.status_code == status.HTTP_401_UNAUTHORIZED       
"

#! Running Tests
1. Create a new file in the root directory named "pytest.ini"
"
[pytest]
DJANGO_SETTINGS_MODULE = storefront.settings
"

** test_collections.py
"
from rest_framework import status
from rest_framework.test import APIClient
import pytest

@pytest.mark.django_db
class TestCreateCollection():
    def test_if_user_is_anonymous_return_401(self):
        #TODO => Format for any test => AAA (Arrange, Act, Assert)
        # Arrange
        
        # Act
        client = APIClient()
        response = client.post('/store/collections/', {'title': 'some title'})
        
        # Assert
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
"
2. Now in the terminal, run command => "pytest" to run all the tests from every app directory.
3. To run test for any individual app, run command => "pytest store/tests"
4. To run only a specific test, run command => "pytest store/tests/test_collections.py"
5. To use a particular class for testing run command => "pytest store/tests/test_collections.py::TestCreateCollection"
6. Use command "pytest -k anonymous" to run only tests that have "anonymous" in their name.

#! Skipping Test
1. To skip any test, add pytest.mark.skip
** test_collections.py
"
from rest_framework import status
from rest_framework.test import APIClient
import pytest

@pytest.mark.django_db
class TestCreateCollection():
    @pytest.mark.skip
    def test_if_user_is_anonymous_return_401(self):
        #TODO => Format for any test => AAA (Arrange, Act, Assert)
        # Arrange
        
        # Act
        client = APIClient()
        response = client.post('/store/collections/', {'title': 'some title'})
        
        # Assert
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
"

#! Continuous Testing
1. pip install pytest-watch (We will use this)
2. Now in terminal run command => "ptw", it will keep watching and run tests continuously whenever the code is changed.

#! Running and Debugging Tests in VS Code
1. Go to "Testing" tab in VS code left panel
2. Select the type of test i.e unittest or pytest
3. Select the location for the test
4. Now run the available test in VS code.

#! Authenticating the user
1. use "client.force_authenticate(user=user)" in the test function to authenticate the user.

** test_collections.py
"
from rest_framework import status
from rest_framework.test import APIClient
import pytest

@pytest.mark.django_db
class TestCreateCollection():
    def test_if_user_is_anonymous_return_401(self):
        #TODO => Format for any test => AAA (Arrange, Act, Assert)
        # Arrange
        
        # Act
        client = APIClient()
        response = client.post('/store/collections/', {'title': 'some title'})
        
        # Assert
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
        
    def test_if_user_is_not_admin_return_403(self):
        client = APIClient()
        client.force_authenticate(user = {})
        response = client.post('/store/collections/', {'title': 'some title'})
        assert response.status_code == status.HTTP_403_FORBIDDEN
"

#! Single or Multiple Assertions
1. Tests should have a single responsibility.

** test_collections.py
"
from django.contrib.auth.models import User
from rest_framework import status
from rest_framework.test import APIClient
import pytest

@pytest.mark.django_db
class TestCreateCollection():
    def test_if_user_is_anonymous_return_401(self):
        #TODO => Format for any test => AAA (Arrange, Act, Assert)
        # Arrange
        
        # Act
        client = APIClient()
        response = client.post('/store/collections/', {'title': 'some title'})
        
        # Assert
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
        
    def test_if_user_is_not_admin_return_403(self):
        client = APIClient()
        client.force_authenticate(user = {})
        response = client.post('/store/collections/', {'title': 'some title'})
        assert response.status_code == status.HTTP_403_FORBIDDEN
        
    def test_if_data_is_invalid_returns_400(self):
        client = APIClient()
        client.force_authenticate(user=User(is_staff=True))
        response = client.post('/store/collections/', {'title': ''})
        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert response.data['title'] is not None
        
    def test_if_data_is_valid_returns_201(self):
        client = APIClient()
        client.force_authenticate(user=User(is_staff=True))
        response = client.post('/store/collections/', {'title': 'some title'})
        assert response.status_code == status.HTTP_201_CREATED
        assert response.data['id'] > 0
"

#! Fixtures
1. Feature of pytest which can be used to remove the repetition of code.
2. Create a fixture in conftest.py under tests folder
3. These fixtures will be available in all the tests even without importing explicitly.
** conftest.py
"
import pytest
from rest_framework.test import APIClient
from django.contrib.auth.models import User

@pytest.fixture
def api_client():
    return APIClient()

@pytest.fixture
def authenticate(api_client):
    def do_authenticate(is_staff=False):
        return api_client.force_authenticate(user=User(is_staff=is_staff))
    return do_authenticate
"
** test_collections.py
"
from django.contrib.auth.models import User
from rest_framework import status
from rest_framework.test import APIClient
import pytest


@pytest.fixture
def create_collection(api_client):
    def do_create_collection(collection):
        return api_client.post("/store/collections/", collection)

    return do_create_collection


@pytest.mark.django_db
class TestCreateCollection:
    def test_if_user_is_anonymous_returns_401(self, create_collection):
        response = create_collection({"title": "a"})

        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    def test_if_user_is_not_admin_returns_403(self, authenticate, create_collection):
        #! Arrange
        authenticate()
        #! Act
        response = create_collection({"title": "a"})
        #! Assert
        assert response.status_code == status.HTTP_403_FORBIDDEN

    def test_if_data_is_invalid_returns_400(self, authenticate, create_collection):
        authenticate(is_staff=True)

        response = create_collection({"title": ""})

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert response.data["title"] is not None

    def test_if_data_is_valid_returns_201(self, authenticate, create_collection):
        authenticate(is_staff=True)

        response = create_collection({"title": "a"})

        assert response.status_code == status.HTTP_201_CREATED
        assert response.data["id"] > 0
"

#! Creating Model Instances
Our previous tests were related to creating instances but now we will be creating model instances to retrieve data from the database.
1. pip install model_bakery
2. Model Bakery will create a dummy db just for testing at the starting of each test and drop it after the test is completed.
** test_collections.py
"
from django.contrib.auth.models import User
from rest_framework import status
from rest_framework.test import APIClient
import pytest
from model_bakery import baker
from store.models import Collection


@pytest.fixture
def create_collection(api_client):
    def do_create_collection(collection):
        return api_client.post("/store/collections/", collection)

    return do_create_collection


@pytest.mark.django_db
class TestCreateCollection:
    def test_if_user_is_anonymous_returns_401(self, create_collection):
        response = create_collection({"title": "a"})

        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    def test_if_user_is_not_admin_returns_403(self, authenticate, create_collection):
        #! Arrange
        authenticate()
        #! Act
        response = create_collection({"title": "a"})
        #! Assert
        assert response.status_code == status.HTTP_403_FORBIDDEN

    def test_if_data_is_invalid_returns_400(self, authenticate, create_collection):
        authenticate(is_staff=True)

        response = create_collection({"title": ""})

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert response.data["title"] is not None

    def test_if_data_is_valid_returns_201(self, authenticate, create_collection):
        authenticate(is_staff=True)

        response = create_collection({"title": "a"})

        assert response.status_code == status.HTTP_201_CREATED
        assert response.data["id"] > 0


@pytest.mark.django_db
class TestRetrieveCollection:
    def test_if_collection_exists_returns_200(self, api_client):
        #! Arrange
        collection = baker.make(Collection)
        #! Act
        response = api_client.get(f'/store/collections/{collection.id}/')

        assert response.status_code == status.HTTP_200_OK
        assert response.data == {
            'id': collection.id,
            'title': collection.title,
            'products_count': 0
        }
"

#* Section - 5 ( Performance Testing )

#! Why Performance Testing?
1. To test and measure the performance of the application.
2. Most companies neglect performance testing but later on face huge issues like application crash etc.
3. Always run performance tests while building an application.
4. Helps us identify and fix performance issues.

#! Installing Locust
There are various performance testing tools but we will use Locust.
1. pip install locust

#! Creating a Test Script
Core Use Cases - 
* Browse products
* Register, sign in and sign out

1. Create a new directory called "locustfiles"
2. Inside that directory, create a new file called "browse_products.py"
3. Write your load tests in that file.
** browse_products.py
"
from locust import HttpUser, task, between
from random import randint

class WebsiteUser(HttpUser):
    #TODO -> * Viewing products * Viewing product details * Add product to cart
    
    #! This will make the tasks wait between 1 and 5 seconds before executing the next task
    wait_time = between(1, 5)
    
    #! This task numbers are weight of each task i.e their priority
    #! Higher number means higher priority
    @task(2)
    def view_products(self):
        print("View products")
        collection_id = randint(2, 6)
        self.client.get(f"/store/products/?collection_id={collection_id}", name="/store/products")

    @task(4) 
    def view_product_details(self):
        print("View product details")
        product_id = randint(1, 1000)
        self.client.get(f"/store/products/{product_id}", name="/store/products/:id")

    @task(1)
    def add_to_cart(self):
        print("Add to cart")
        product_id = randint(1, 10)
        self.client.post(f"/store/carts/{self.cart_id}/items/", name="/store/carts/items/", json={'product_id': product_id, 'quantity': 1})

    #! This is not a task but will run on start of every load test
    def on_start(self):
        response = self.client.post("/store/carts/")
        result = response.json()
        self.cart_id = result["id"]
"

#! Running a load test script
1. In terminal, run command => "locust -f locustfiles/browse_products.py", you will see terminal output like
"
Ultimate Django Series 3> locust -f .\locustfiles\browse_products.py
[2024-07-16 13:00:34,893] INFO/locust.main: Starting web interface at http://localhost:8089 (accepting connections from all network interfaces)
[2024-07-16 13:00:34,932] INFO/locust.main: Starting Locust 2.29.1
"
2. Now in the locust webpage, set 
* Number of users = 1
* Ramp up = 1
* Host = http://localhost:8000
and click on "Start" button.

#! Performance Testing Optimization
1. Optimize the code, remove unnecessary code, etc. Refer "tips.txt"
2. Re-write the query
3. Tune the database
4. Cache the results

#! Profiling with Silk
Now that we have identified the slow endpoints, we will now have to identify the source of the issue. For this, we will use "Silk".
1. pip install django-silk
2. Add it to INSTALLED_APPS in settings.py => "silk"
3. Add it to MIDDLEWARE in settings.py => "silk.middleware.SilkyMiddleware"
"
if DEBUG:
    MIDDLEWARE += [
        'silk.middleware.SilkyMiddleware',
    ]
"
4. Add it to urls.py => urlpatterns += [path('silk/', include('silk.urls', namespace='silk'))] inside the settings.DEBUG
"
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
    urlpatterns += [path('silk/', include('silk.urls', namespace='silk'))]
"
5. Now run migration command => "python manage.py migrate"
6. Now go to "127.0.0.1:8000/silk/", you will see the dashboard. You can access every detail of the endpoints along with the sql queries running in the background with its execution time.

#! Verifying Optimizations
1. Rerun the locust performance test after making Optimizations and also comment out the Silk middleware as it adds a lot of overhead.

#! Stress Testing
1. Load test your application with around 1000 users.

#* Section - 6 ( Caching )
Caching is a technique that improves the performance of your application.

#! What is Caching?
When we send a request to server, it gets the data from the database and then sends it back to the user. If the data is not modified, it is cached (stored) in the server. If the data is modified, it is sent to the server again. This is called caching.

* Highly benificial for performance
* Caching is used to improve the performance of your application
* Imagine if we use a 3rd party api and the api is slow or crashes, still we can get the data from the cache
* Caching too much data can slow down your application

#! Cache Backends
Various types of cache backends are available:
* Local memory (default)
* Redis ( We will use this )
* Memcached
* Database

#! Simulate a slow api
** playground/views.py
"
from django.shortcuts import render
import requests

def say_hello(request):
    #! This will get you the response after 10 seconds of request
    requests.get('http://httpbin.org/delay/1')
    return render(request, "hello.html", {"name": "Ayush Senapati"})
"

#! Getting a baseline performance benchmark
* Run the load test with 5 users sending 10 requests per second
Benchmarks:
"
Response time percentiles (approximated)
Type     Name                                                                                  50%    66%    75%    80%    90%    95%    98%    99%  99.9% 99.99%   100% # reqs
--------|--------------------------------------------------------------------------------|--------|------|------|------|------|------|------|------|------|------|------|------
GET      /playground/hello/                                                                   3400   3400   3400   3400   3400   3400   3400   3400   3400   3400   3400      2
POST     /store/carts/                                                                        2100   2100   2100   2100   2100   2100   2100   2100   2100   2100   2100      5
POST     /store/carts/items/                                                                    25     27     27     30     30     30     30     30     30     30     30      5
GET      /store/products                                                                        26     27     33     49     62     66     66     66     66     66     66     14
GET      /store/products/:id                                                                  2100   2100   2100   2100   2100   2100   2100   2100   2100   2100   2100     35
--------|--------------------------------------------------------------------------------|--------|------|------|------|------|------|------|------|------|------|------|------
         Aggregated                                                                           2100   2100   2100   2100   2100   2100   3000   3400   3400   3400   3400     61
"

#! Installing Redis
1. Install Redis on your machine either through windows forked version or the docker image.
2. Run the docker image => "docker run -d -p 6379:6379 redis" where -d is for detached mode so that it runs in the background and -p is for port mapping.

#! Configuring Redis
1. Install django-redis => "pip install django-redis"
2. Go to its official documentation => "https://pypi.org/project/django-redis/" or its github page
3. Add these to settings.py
** settings.py
"
#! Django-redis cache configuration
CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/2",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    }
}
"

#! using the Low-Level Cache API
** playground/views.py
"
from django.shortcuts import render
import requests
from django.core.cache import cache

#! A string "httpbin_result" is defined as the cache key. This key will be used to store and retrieve cached data.
#! The cache.get(key) method attempts to fetch data from the cache using the defined key. If no data exists (i.e., it returns None), the function proceeds to fetch data from an external source.
def say_hello(request):
    key = "httpbin_result"
    if cache.get(key) is None:
        response = requests.get('http://httpbin.org/delay/2')
        data = response.json()
        cache.set(key=key, value=data)
        # cache.set(key, data, 60)
    return render(request, "hello.html", {"name": cache.get(key)})
"

We can globally set a timeout for cache retention in settings.py
* The timeout can be set to automatically expire the cache after a certain period.
** settings.py
"
#! Django-redis cache configuration
CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/2",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        },
        "TIMEOUT": 10 * 60, #! 10 minutes
    }
}
"

#! Caching Views
1. Rather than writing this code everywhere in the views, to avoid repeatition, we can use decorators
* Purpose: The @cache_page decorator is specifically designed for caching the output of Django views. When applied to a view function, it tells Django to cache the entire response generated by the view for a specified duration.
* Parameters: The parameter passed to @cache_page specifies the cache duration in seconds. In this case, 5 * 60 means the cache will expire after 5 minutes.

** playground/views.py
#? Function Based View
"
from django.shortcuts import render
import requests
from django.core.cache import cache
from django.views.decorators.cache import cache_page

@cache_page(5 * 60)
def say_hello(request):
    response = requests.get("http://httpbin.org/delay/2")
    data = response.json()
    return render(request, "hello.html", {"name": data})
"

#? Class Based View
"
from django.shortcuts import render
import requests
from django.core.cache import cache
from django.views.decorators.cache import cache_page
from django.utils.decorators import method_decorator
from rest_framework.views import APIView

class HelloView(APIView):
    @method_decorator(cache_page(5 * 60)) #! We cannot utilize decorators directly on class based views so we use method_decorator
    def get(self, request):
        response = requests.get("http://httpbin.org/delay/2")
        data = response.json()
        return render(request, "hello.html", {"name": "Ayush Senapati"})

"

#! Verifying Optimizations using Caching
1. We will perform another performance load test so restart the locust server
2. Again use 5 users with 10 requests per second

Before Caching:
"
Type     Name                                                                          # reqs      # fails |    Avg     Min     Max    Med |   req/s  failures/s
--------|----------------------------------------------------------------------------|-------|-------------|-------|-------|-------|-------|--------|-----------
GET      /playground/hello/                                                                15     0(0.00%) |   2753    2518    3194   2700 |    0.12        0.00
POST     /store/carts/                                                                      5     0(0.00%) |   2076    2074    2078   2078 |    0.04        0.00
POST     /store/carts/items/                                                               20     0(0.00%) |     13       7      18     14 |    0.16        0.00
GET      /store/products                                                                   41     0(0.00%) |     15       8      30     15 |    0.32        0.00
GET      /store/products/:id                                                               72     0(0.00%) |   2058    2025    2082   2082 |    0.56        0.00
--------|----------------------------------------------------------------------------|-------|-------------|-------|-------|-------|-------|--------|-----------
         Aggregated                                                                       153     0(0.00%) |   1312       7    3194   2100 |    1.19        0.00

Response time percentiles (approximated)
Type     Name                                                                                  50%    66%    75%    80%    90%    95%    98%    99%  99.9% 99.99%   100% # reqs
--------|--------------------------------------------------------------------------------|--------|------|------|------|------|------|------|------|------|------|------|------
GET      /playground/hello/                                                                   2700   2800   3000   3100   3100   3200   3200   3200   3200   3200   3200     15
POST     /store/carts/                                                                        2100   2100   2100   2100   2100   2100   2100   2100   2100   2100   2100      5
POST     /store/carts/items/                                                                    14     15     17     17     18     19     19     19     19     19     19     20
GET      /store/products                                                                        15     16     17     17     18     18     30     30     30     30     30     41
GET      /store/products/:id                                                                  2100   2100   2100   2100   2100   2100   2100   2100   2100   2100   2100     72
--------|--------------------------------------------------------------------------------|--------|------|------|------|------|------|------|------|------|------|------|------
         Aggregated                                                                           2100   2100   2100   2100   2100   2700   3000   3100   3200   3200   3200    153
"

After Caching:
"
Type     Name                                                                          # reqs      # fails |    Avg     Min     Max    Med |   req/s  failures/s
--------|----------------------------------------------------------------------------|-------|-------------|-------|-------|-------|-------|--------|-----------
GET      /playground/hello/                                                                21     0(0.00%) |    131       1    2650      6 |    0.18        0.00
POST     /store/carts/                                                                      5     0(0.00%) |   2077    2075    2079   2079 |    0.04        0.00
POST     /store/carts/items/                                                               20     0(0.00%) |     13       8      22     13 |    0.17        0.00
GET      /store/products                                                                   41     0(0.00%) |     16       6      36     17 |    0.35        0.00
GET      /store/products/:id                                                               63     0(0.00%) |   2060    2033    2107   2100 |    0.53        0.00
--------|----------------------------------------------------------------------------|-------|-------------|-------|-------|-------|-------|--------|-----------
         Aggregated                                                                       150     0(0.00%) |    959       1    2650     20 |    1.26        0.00

Response time percentiles (approximated)
Type     Name                                                                                  50%    66%    75%    80%    90%    95%    98%    99%  99.9% 99.99%   100% # reqs
--------|--------------------------------------------------------------------------------|--------|------|------|------|------|------|------|------|------|------|------|------
GET      /playground/hello/                                                                      6      7      7      7      8      9   2700   2700   2700   2700   2700     21
POST     /store/carts/                                                                        2100   2100   2100   2100   2100   2100   2100   2100   2100   2100   2100      5
POST     /store/carts/items/                                                                    13     16     18     18     20     22     22     22     22     22     22     20
GET      /store/products                                                                        17     18     19     19     21     21     36     36     36     36     36     41
GET      /store/products/:id                                                                  2100   2100   2100   2100   2100   2100   2100   2100   2100   2100   2100     63
--------|--------------------------------------------------------------------------------|--------|------|------|------|------|------|------|------|------|------|------|------
         Aggregated                                                                             21   2100   2100   2100   2100   2100   2100   2100   2700   2700   2700    150
""

* We can compare the average response time and median in before and after tables for /playground/hello/ and see the level of impact received by caching.

#! Managing Redis Cache Content
1. Type "docker ps" to check all the containers which are running.
"
(venv) PS D:\Ultimate-Django-Series\Ultimate Django Series 3> docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                    NAMES
575e107fd69e   redis     "docker-entrypoint.sâ€¦"   34 seconds ago   Up 33 seconds   0.0.0.0:6379->6379/tcp   zealous_lehmann
"
2. Now to run or execute some commands inside a container, we will use "docker exec" command.
"(venv) PS D:\Ultimate-Django-Series\Ultimate Django Series 3> docker exec -it 575e107fd69e redis-cli
127.0.0.1:6379> ping
PONG
"
3. Here, first write "docker exec -it" then the container id and then the command we want to execute which in this case is "redis-cli".
@NOTE: Redis Databases have only numbers rather than names to identify them.
4. Now as we know that we have 2 databases in redis, "1" is used as message broker and "2" is used as cache. 
* In order to clear the cache we will use "FLUSHALL" command.
5. Type "select 2" to switch to database "2".
"
127.0.0.1:6379> select 2
OK
"
6. If you type "keys *" you will get all the keys in database "2". These are the keys in the cache.
* When no cache is stored
"
127.0.0.1:6379[2]> keys *
(empty array)
"
* When cache is stored
"
127.0.0.1:6379[2]> keys *
:1:views.decorators.cache.cache_page...
"
7. To delete any key from cache we will use "del" command.
"
127.0.0.1:6379[2]> del :1:views.decorators.cache.cache_page...
"
8, In order to clear all the keys from cache we will use "flushall" command.
"
127.0.0.1:6379[2]> flushall
OK
"

* To debug any container or image
'Try Docker Debug for seamless, persistent debugging tools in any container or image â†’ docker debug <container_id>'

#* Section - 7 ( Preparing for Production )

#! Adding the Home Page
1. Create a homepage for the application so that we get a page rather than error for url "localhost:8000".
2. Create core/templates/core/index.html
3. Create core/urls.py
"
from django.views.generic import TemplateView
from django.urls import path

urlpatterns = [
    path("", TemplateView.as_view(template_name="core/index.html")),
]
"
4. Add this core/urls.py to storefront/urls.py using "path("", include("core.urls")),"
5. Now go to "127.0.0.1:8000" and you will see the homepage.

#! Managing Static Assets
1. Create a static folder in the core directory.
2. Create static/core/style.css and static/core/logo.png
3. Update your index.html
"
{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="{% static 'core/styles.css' %}" />
  </head>
  <body>
    <div class="home-page">
      <img src="{% static 'core/logo.png' %}" alt="Logo" class="logo" />
    </div>
  </body>
</html>
"

#! Collecting Static Assets
0. Add this to settings.py
"
STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'static')
"
1. Type "python manage.py collectstatic" in the terminal.
2. This command will create a static folder in the project which will be a summation of all the static files in the project app directories.
"
(venv) PS D:\Ultimate-Django-Series\Ultimate Django Series 3> python manage.py collectstatic 

262 static files copied to 'D:\Ultimate-Django-Series\Ultimate Django Series 3\static'.
"

#! Serving Static Assets
1. Django has command to collect static assets but doesn't provide a way to serve them.
2. So to serve these assets, we will use "whitenoise" package.
3. pip install whitenoise
4. Add Middleware in settings.py
"
MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    # 'debug_toolbar.middleware.DebugToolbarMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware', #! Add whitenoise middleware right after security
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    # 'silk.middleware.SilkyMiddleware',
]
"

#! Configuring Logging
Use logging to diagnose and troubleshoot issues.
#TODO -> https://betterstack.com/community/guides/logging/how-to-start-logging-with-python/

Add this to settings.py
** settings.py
"
#! Logging configuration
LOGGING = {
    #! Version of logging
    'version': 1,
    #! disable logging to previous handlers
    'disable_existing_loggers': False,
    #! Where to handle and send logging data
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': 'general.log',
        }
    },
    #! Define which apps will use logging
    'loggers': {
        #! For the entire project we use "django"
        'django': {
            'handlers': ['console', 'file'], #! For the entire project we want the logs to be sent to "console" and "file"
            'level': os.environ.get('DJANGO_LOG_LEVEL', 'INFO'), #! SEVERITY => DEBUG, INFO, WARNING, ERROR, CRITICAL. By default, it is "INFO" here
        },
    },
    #! Formatters for logging
    'formatters': {
        #! For detailed structuring of logs
        'verbose': {
            # 'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'format': '{asctime} ({levelname}) - {name} - {message}',
            'style': '{', #! '{' means str.format()
            # 'style': '$', #! '$' means str.template()
        },
        #! For simple structuring of logs
        # 'simple': {
        #     'format': '{levelname} {message}',
        #     'style': '{',
        # },
    }
}
""
#! Logging
** playground/views.py
"
from django.shortcuts import render
import requests
import logging
from django.core.cache import cache
from django.views.decorators.cache import cache_page
from django.utils.decorators import method_decorator
from rest_framework.views import APIView

# Approach - 1 (Basic)
# logger = logging.getLogger("playground.views") #! This will make a new logger with name 'playground.views'

# Approach - 2 (Optimized)
logger = logging.getLogger(
    __name__
)  #! This will make a new logger with name 'playground.views' dynamically according to the file name


class HelloView(APIView):
    def get(self, request):
        try:
            logger.info("Calling httpbin.org/delay/2")
            response = requests.get("http://httpbin.org/delay/2")
            logger.info("Received response from httpbin.org/delay/2")
            data = response.json()
        except requests.ConnectionError:
            logger.critical("httpbin is offline. Could not connect to httpbin.org/delay/2")
        return render(request, "hello.html", {"name": "Ayush Senapati"})

"

** general.log
"
2024-07-20 19:40:54,608 (INFO) - django.utils.autoreload - Watching for file changes with StatReloader
2024-07-20 19:40:55,074 (WARNING) - silk.profiling.profiler - Cannot execute silk_profile as silk is not installed correctly.
2024-07-20 19:46:21,385 (INFO) - playground.views - Calling httpbin.org/delay/2
2024-07-20 19:46:23,965 (INFO) - playground.views - Received response from httpbin.org/delay/2
""

#! Managing Development and Production Settings
1. To differentiate between development and production settings, we will create settings directory inside project directory.
2. Inside the settings directory, create cpmmmon.py, dev.py and prod.py
3. Move the settings.py to settings directory
4. Rename settings.py to common.py
5. Now cut paste the required settings to dev.py and prod.py
** settings/dev.py
"
from .common import *

SECRET_KEY = 'django-insecure-hs6j037urx6iav+7#10%-vu4l4f5@@-1_zo)oft4g7$vf2$jmp'

DEBUG = True

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'storefront3',
        'HOST': 'localhost',
        'USER': 'root',
        'PASSWORD': 'Ab@123456'
    }
}
"
** prod.py
"
from .common import *
import os

SECRET_KEY = os.environ['SECRET_KEY']

DEBUG = False

ALLOWED_HOSTS = []
"

6. Search for "DJANGO_SETTINGS_MODULE" and change "DJANGO_SETTINGS_MODULE = storefront.settings" to "DJANGO_SETTINGS_MODULE = storefront.settings.dev"
7. Change "BASE_DIR = Path(__file__).resolve().parent.parent" to "BASE_DIR = Path(__file__).resolve().parent.parent.parent" in common.py

#! Serving the application with Gunicorn
1. For production, we need a fast and robust webserver. We can use Gunicorn.
2. pip install gunicorn
3. Now we will use the wsgi.py which stands for Web Server Gateway Interface.

"Daphne serves as an ASGI server, primarily handling asynchronous tasks like WebSocket connections. It's used for Django Channels. Daphne does not serve WSGI applications. For synchronous HTTP requests (WSGI), you still need a traditional WSGI server like Gunicorn ."

3. Start the gunicorn server with "gunicorn storefront.wsgi"
"
(venv) PS D:\Ultimate-Django-Series\Ultimate Django Series 3> gunicorn storefront.wsgi
Traceback (most recent call last):
  File "<frozen runpy>", line 198, in _run_module_as_main
  File "<frozen runpy>", line 88, in _run_code
  File "D:\Ultimate-Django-Series\venv\Scripts\gunicorn.exe\__main__.py", line 4, in <module>
  File "D:\Ultimate-Django-Series\venv\Lib\site-packages\gunicorn\app\wsgiapp.py", line 9, in <module>  
    from gunicorn.app.base import Application
  File "D:\Ultimate-Django-Series\venv\Lib\site-packages\gunicorn\app\base.py", line 11, in <module>    
    from gunicorn import util
  File "D:\Ultimate-Django-Series\venv\Lib\site-packages\gunicorn\util.py", line 8, in <module>
    import fcntl
ModuleNotFoundError: No module named 'fcntl'
"
* We get this error because gunicorn is only supported for Unix based systems like Linux and macOS. 
* For Windows, we can use it with Windows Subsystem for Linux or use a WSGI server compatible with Windows, such as waitress, for development purposes.

#! Serving the application with waitress
1. pip install waitress
2. To start the application with waitress, run "waitress-serve --port=8000 storefront.wsgi:application"
"
(venv) PS D:\Ultimate-Django-Series\Ultimate Django Series 3> waitress-serve --port=8000 storefront.wsgi:application
Serving on http://0.0.0.0:8000
Cannot execute silk_profile as silk is not installed correctly.
Calling httpbin.org/delay/2
Received response from httpbin.org/delay/2
"
#TODO Refer => https://docs.pylonsproject.org/projects/waitress/en/latest/usage.html

#* Section - 8 ( Deployment )
Hosting Options - 
a) Virtual Private Server (VPS)
b) Platform as a Service (PaaS)
* Heroku (We will use this)
* Digital Ocean
* AWS
* MS Azure
* Google Cloud

#! Adding Project to Git
1. git init
2. git add .
3. git commit -m "initial commit"
4. git log --oneline
5. git push -u origin main

#! Getting Started with Heroku
1. Create a Heroku account
2. Download the Heroku CLI from "https://devcenter.heroku.com/articles/heroku-cli"
3. Run "heroku --version"
4. Run "heroku login"
"
PS D:\Ultimate-Django-Series\Ultimate Django Series 3> heroku --version
heroku/9.0.0 win32-x64 node-v16.20.2
PS D:\Ultimate-Django-Series\Ultimate Django Series 3> heroku login
heroku: Press any key to open up the browser to login or q to exit:
Opening browser to https://cli-auth.heroku.com/auth/cli/browser/28676797-bb14-4cfd-a995-c1faf3fafbf6?requestor=SFMyNTY.g2gDbQAAAA00OS4zNy4xMTQuMjQ0bgYAOGof1JABYgABUYA.Ge6IupZV9hhPpCThnvzaab1rhWNxBVQSsFfmc61GcfI
Logging in... done
Logged in as ayush.senapati@cozentus.com
"

#! Creating a heroku App
1. Create a new heroku app using "heroku create <app-name>"
"
(venv) PS D:\Ultimate-Django-Series\Ultimate Django Series 3> heroku create senpaibuys-prod
Creating â¬¢ senpaibuys-prod... !
    Error: HTTP Error 503 for POST https://api.heroku.com/apps
    <!DOCTYPE html>
    <html>
      <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta charset="utf-8">
        <title>Application Error</title>
        <style media="screen">
          html,body,iframe {
            margin: 0;
            padding: 0;
          }

          html,body {
            height: 100%;
            overflow: hidden;
          }

          iframe {
            width: 100%;
            height: 100%;
            border: 0;
          }
        </style>
      </head>
      <body>
        <iframe
    src="https://www.herokucdn.com/error-pages/application-error.html"></iframe>
      </body>
    </html>
(venv) PS D:\Ultimate-Django-Series\Ultimate Django Series 3>

(venv) PS D:\Ultimate-Django-Series\Ultimate Django Series 3> heroku create senpaibuys-prod
Creating â¬¢ senpaibuys-prod... !
 Â»   Error: To create an app, verify your account by adding payment information. Verify now
 Â»    at https://heroku.com/verify Learn more at
 Â»   https://devcenter.heroku.com/articles/account-verification
 Â»
 Â»   Error ID: verification_required
"
"
We are getting this error because heroku is not free anymore

** storefront/settings/prod.py
"
from .common import *
import os

SECRET_KEY = os.environ['SECRET_KEY']

DEBUG = False

# ALLOWED_HOSTS = ['senpaibuys-prod.herokuapp.com'] #! This would have been the allowed host in production for heroku app
ALLOWED_HOSTS = []
"

#! Setting Environment Variables
1. We need to create a SECRET_KEY for production 
2. Go to "djecrety.ir" and generate a secret key
3. Run "heroku config:set SECRET_KEY=<SECRET_KEY>"
4. Run "heroku config:set DJANGO_SETTINGS_MODULE=storefront.settings.prod"
5. Run "heroku config:set DEBUG=False"

#! Creating a Proc file (needed only with Heroku)
1. Create a "Procfile" in the root directory
** Procfile
"
release: python manage.py migrate
web: gunicorn storefront.wsgi
worker: celery -A storefront.celery worker --pool=solo -l info
"

#! Provisioning a MySQL Database
1. Go to "dashboard.heroku.com/apps" to see your apps.
2. Click on your app
3. Click "Configure Add-ons"
4. Search for "ClearDB MySQL" 
5. Now in the terminal, type "heroku config" to see your config variables
6. You will see a new env variable called "CLEARDB_DATABASE_URL"
7. Copy the value of "CLEARDB_DATABASE_URL" before the part where ?reconnect=true is present
8. Now type "heroku config:set DATABASE_URL=<YOUR-CLEARDB-DATABASE-URL>"

9. Now to set the database parameters in prod, we will use package => "dj-database-url"
10. pip install dj-database-url
11. Now update your prod.py
** storefront/settings/prod.py
"
from .common import *
import dj_database_url
import os

SECRET_KEY = os.environ['SECRET_KEY']

DEBUG = False

ALLOWED_HOSTS = []

DATABASES = {
    'default': dj_database_url.config()
}
"

#! Provisioning a Redis Instance
1. Now again go to "dashboard.heroku.com/apps" to see your apps.
2. Configure Add-ons
3. Search for "Heroku Redis"
4. In the terminal, type "heroku config" to see your config variables
5. We will see a new env variable called "REDIS_URL"

#! Provisioning a SMTP Server
1. Go to "dashboard.heroku.com/apps" to see your apps.
2. Click on your app
3. Click "Configure Add-ons"
4. Search for "Mailgun"
5. Now in the terminal, type "heroku config" to see your config variables
6. You will see "MAILGUN_PUBLIC_KEY", "MAILGUN_SMTP_LOGIN", "MAILGUN_SMTP_PASSWORD", "MAILGUN_SMTP_SERVER", "MAILGUN_SMTP_PORT"
7. Make changes in prod.py
"
from .common import *
import dj_database_url
import os

SECRET_KEY = os.environ['SECRET_KEY']

DEBUG = False

ALLOWED_HOSTS = []

DATABASES = {
    'default': dj_database_url.config()
}

REDIS_URL = os.environ['REDIS_URL']

CELERY_BROKER_URL = REDIS_URL

CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": REDIS_URL,
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        },
        "TIMEOUT": 10 * 60, #! 10 minutes
    }
}

EMAIL_HOST = os.environ['MAILGUN_SMTP_SERVER']
EMAIL_HOST_USER = os.environ['MAILGUN_SMTP_LOGIN']
EMAIL_HOST_PASSWORD = os.environ['MAILGUN_SMTP_PASSWORD']
EMAIL_PORT = os.environ['MAILGUN_SMTP_PORT']
"

#! Deploying the Application
* install heroku-postgres from the configure add-ons
* type "heroku config", you will see HEROKU_POSTGRESQL_NAVY_URL
* copy the value of HEROKU_POSTGRESQL_NAVY_URL to DATABASE_URL
* type "heroku config:set DATABASE_URL=<YOUR-HEROKU_POSTGRESQL_NAVY_URL>"

1. git add .
2. git commit -m "commit message"
3. git push origin master
4. git remote -vv 
5. git push heroku master

* To view the deployed files => heroku run bash
* To view the logs => heroku logs --tail
* To create a superuser => heroku run python manage.py createsuperuser

* heroku open => open the app in a browser

#! Populating the Database
Approach - 1
1. We will use our custom command "seed_db" present in store/management/commands/seed_db.py
2. Type "heroku run python manage.py seed_db"
Approach - 2
1. heroku config:get DATABASE_URL
2. Copy the value of DATABASE_URL
3. Go to your database IDE
4. Open a new datasource or new connection
5. connection type => url only
6. In the URL field, paste the value of DATABASE_URL => jdbc:<DATABASE_URL>
7. Now you can populate the database

#! Dockerizing the Application
* Services we need to run the application:
a) MySQL (For database)
b) Redis (For caching)
c) Celery (For background tasks)
d) Smtp4Dev (For sending emails)
e) Flower (For monitoring)
f) Silk (For profiling)
g) Locust (For performance testing)

1. Go to task manager then to services and stop mysql service because we will be running it through docker so we need the port free
2. Create 4 files in the root directory
a) docker-compose.yml
b) Dockerfile
c) docker-entrypoint.sh
d) wait-for-it.sh

3. Run command => docker-compose up --build -d 
"
PS D:\Ultimate-Django-Series\Ultimate Django Series 3> docker-compose up --build
time="2024-07-21T20:46:12+05:30" level=warning msg="D:\\Ultimate-Django-Series\\Ultimate Django Series 3\\docker-compose.yml: `version` is obsolete"
error during connect: Get "http://%2F%2F.%2Fpipe%2FdockerDesktopLinuxEngine/v1.46/containers/json?all=1&filters=%7B%22label%22%3A%7B%22com.docker.compose.config-hash%22%3Atrue%2C%22com.docker.compose.project%3Dultimatedjangoseries3%22%3Atrue%7D%7D": open //./pipe/dockerDesktopLinuxEngine: The system cannot find the file specified.
PS D:\Ultimate-Django-Series\Ultimate Django Series 3> docker-compose up --build
time="2024-07-21T20:47:11+05:30" level=warning msg="D:\\Ultimate-Django-Series\\Ultimate Django Series 3\\docker-compose.yml: `version` is obsolete"
[+] Running 20/3
 âœ” smtp4dev Pulled                                                                                                                                                                                                             2.7s 
 - mysql [â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿] 166.7MB / 166.8MB Pulling                                                                                                                                                                              28.3s 
 âœ” redis Pulled                                                                                                                                                                                                                8.0s 
""
4. To check logs from our web server => docker-compose logs web 
5. To check logs from test server => docker-compose logs tests
6. docker-compose logs -f tests => to see the logs in real time
7. docker-compose down => to stop all the containers
8. To run commands => docker-compose run web bash
9. To seed the database => docker-compose run web python manage.py seed_db

-------------------------------------------------------------------------------------------THE END-------------------------------------------------------------------------------------------