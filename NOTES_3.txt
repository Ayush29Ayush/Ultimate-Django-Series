#! Setting Up the Project and Database
1. Open MySQL Workbench and create a new database named storefront3.
2. Run "python manage.py makemigrations" and "python manage.py migrate" to create the tables in the database.
3. Now rather than using the seed.sql directly to import the data in the database using the SQL Workbench, we will use a custom command.
4. Create a custom command named "seed_db" my creating a management folder followed by a commands folder inside the store app. 
5. Write the following code in seed_db.py and place seed.sql file in the same directory.
"
#! CUSTOM COMMAND TO POPULATE THE DATABASE
from django.core.management.base import BaseCommand
from django.db import connection
from pathlib import Path
import os


class Command(BaseCommand):
    help = 'Populates the database with collections and products'

    def handle(self, *args, **options):
        print('Populating the database...')
        current_dir = os.path.dirname(__file__)
        file_path = os.path.join(current_dir, 'seed.sql')
        sql = Path(file_path).read_text()

        with connection.cursor() as cursor:
            cursor.execute(sql)

"
6. Now in the terminal, just type "python manage.py", we will see this output::
"
(venv) PS D:\Ultimate-Django-Series\Ultimate Django Series 3> python .\manage.py

Type 'manage.py help <subcommand>' for help on a specific subcommand.

Available subcommands:

[auth]
    changepassword
    createsuperuser

[contenttypes]
    remove_stale_contenttypes

[debug_toolbar]
    debugsqlshell

[django]
    check
    compilemessages
    createcachetable
    dbshell
    diffsettings
    flush
    inspectdb
    loaddata
    makemessages
    makemigrations
    migrate
    optimizemigration
    sendtestemail
    shell
    showmigrations
    sqlflush
    sqlmigrate
    sqlsequencereset
    squashmigrations
    startapp
    startproject
    test
    testserver

[rest_framework]
    generateschema

[sessions]
    clearsessions

[staticfiles]
    collectstatic
    findstatic
    runserver

[store]
    seed_db
"
7. Now run the "python manage.py seed_db" command to populate the database.

#* Overview
1. Uploading Files
2. Sending emails
3. Running Background Tasks
4. Automated testing
5. Performance testing
6. Caching, etc.

#* Section - 1 (Uploading Files)

#! Managing Media Files 
1. Create a "media" folder in the root directory of the project.
2. Imsert any image in the media folder.
3. Add MEDIA_URL and MEDIA_ROOT to settings.py.
"
MEDIA_URL = '/media/'
# MEDIA_ROOT = BASE_DIR / 'media'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
"
4. Add these to urls.py of the project directory.
"
from django.conf import settings
from django.conf.urls.static import static
from django.contrib import admin
from django.urls import path, include
import debug_toolbar

admin.site.site_header = "Storefront Admin"
admin.site.index_title = "Admin"

urlpatterns = [
    path("admin/", admin.site.urls),
    path("playground/", include("playground.urls")),
    path("store/", include("store.urls")),
    path("auth/", include("djoser.urls")),
    path("auth/", include("djoser.urls.jwt")),
    path("__debug__/", include(debug_toolbar.urls)),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
"
5. Now go to "127.0.0.1:8000/media/{image.png}" and you will see the image in the browser. 

#! Adding Images to Products
1. Create a fact table for Product table which will be a one to many relationship (Product)(1) -> (Image)(n)
2. Add the following model in models.py
"
class ProductImage(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(upload_to='store/images', blank=True, null=True)
"
#! Building an API to Upload Images 
1. Now we will create a API with url like "/products/1/images/1"
Step-1: Create a serializer
Step-2: Create a viewset
Step-3: Create a router

** serializers.py
"
class ProductImageSerializer(serializers.ModelSerializer):
    def create(self, validated_data):
        product_id = self.context['product_id']
        return ProductImage.objects.create(product_id=product_id, **validated_data)
    class Meta:
        model = ProductImage
        fields = ['id', 'image']
"
** views.py
"
class ProductImageViewSet(ModelViewSet):
    serializer_class = ProductImageSerializer
    # queryset = ProductImage.objects.all()
    
    def get_serializer_context(self):
        return {'product_id': self.kwargs['product_pk']}
    
    #! URL like "/products/1(product_pk)/images/1(pk)"
    def get_queryset(self):
        return ProductImage.objects.filter(product_id=self.kwargs['product_pk'])
"
** urls.py
"
products_router.register('images', views.ProductImageViewSet, basename='product-images')
"

Now the urlpatterns looks like this:
"
[<URLPattern '^products/$' [name='products-list']>,
 <URLPattern '^products\.(?P<format>[a-z0-9]+)/?$' [name='products-list']>,
 <URLPattern '^products/(?P<pk>[^/.]+)/$' [name='products-detail']>,
 <URLPattern '^products/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='products-detail']>,
 <URLPattern '^collections/$' [name='collection-list']>,
 <URLPattern '^collections\.(?P<format>[a-z0-9]+)/?$' [name='collection-list']>,
 <URLPattern '^collections/(?P<pk>[^/.]+)/$' [name='collection-detail']>,
 <URLPattern '^collections/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='collection-detail']>,
 <URLPattern '^carts/$' [name='cart-list']>,
 <URLPattern '^carts\.(?P<format>[a-z0-9]+)/?$' [name='cart-list']>,
 <URLPattern '^carts/(?P<pk>[^/.]+)/$' [name='cart-detail']>,
 <URLPattern '^carts/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='cart-detail']>,
 <URLPattern '^customers/$' [name='customer-list']>,
 <URLPattern '^customers\.(?P<format>[a-z0-9]+)/?$' [name='customer-list']>,
 <URLPattern '^customers/me/$' [name='customer-me']>,
 <URLPattern '^customers/me\.(?P<format>[a-z0-9]+)/?$' [name='customer-me']>,
 <URLPattern '^customers/(?P<pk>[^/.]+)/$' [name='customer-detail']>,
 <URLPattern '^customers/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='customer-detail']>,
 <URLPattern '^customers/(?P<pk>[^/.]+)/history/$' [name='customer-history']>,
 <URLPattern '^customers/(?P<pk>[^/.]+)/history\.(?P<format>[a-z0-9]+)/?$' [name='customer-history']>,
 <URLPattern '^orders/$' [name='orders-list']>,
 <URLPattern '^orders\.(?P<format>[a-z0-9]+)/?$' [name='orders-list']>,
 <URLPattern '^orders/(?P<pk>[^/.]+)/$' [name='orders-detail']>,
 <URLPattern '^orders/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='orders-detail']>,
 <URLPattern '' [name='api-root']>,
 <URLPattern '<drf_format_suffix:format>' [name='api-root']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/reviews/$' [name='product-reviews-list']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/reviews\.(?P<format>[a-z0-9]+)/?$' [name='product-reviews-list']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/reviews/(?P<pk>[^/.]+)/$' [name='product-reviews-detail']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/reviews/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='product-reviews-detail']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/images/$' [name='product-images-list']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/images\.(?P<format>[a-z0-9]+)/?$' [name='product-images-list']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/images/(?P<pk>[^/.]+)/$' [name='product-images-detail']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/images/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='product-images-detail']>,
 <URLPattern '' [name='api-root']>,
 <URLPattern '<drf_format_suffix:format>' [name='api-root']>,
 <URLPattern '^carts/(?P<cart_pk>[^/.]+)/items/$' [name='cart-items-list']>,
 <URLPattern '^carts/(?P<cart_pk>[^/.]+)/items\.(?P<format>[a-z0-9]+)/?$' [name='cart-items-list']>,
 <URLPattern '^carts/(?P<cart_pk>[^/.]+)/items/(?P<pk>[^/.]+)/$' [name='cart-items-detail']>,
 <URLPattern '^carts/(?P<cart_pk>[^/.]+)/items/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='cart-items-detail']>,
 <URLPattern '' [name='api-root']>,
 <URLPattern '<drf_format_suffix:format>' [name='api-root']>]
"

#! Returning Images from the Product API
1. We need images to be returned in the Product API
2. Add images to the ProductSerializer
** serializer.py
"
class ProductImageSerializer(serializers.ModelSerializer):
    def create(self, validated_data):
        product_id = self.context['product_id']
        return ProductImage.objects.create(product_id=product_id, **validated_data)
    class Meta:
        model = ProductImage
        fields = ['id', 'image']

class ProductSerializer(serializers.ModelSerializer):
    images = ProductImageSerializer(many=True, read_only=True)
    class Meta:
        model = Product
        fields = ['id', 'title', 'description', 'slug', 'inventory',
                  'unit_price', 'price_with_tax', 'collection', 'images']

    price_with_tax = serializers.SerializerMethodField(
        method_name='calculate_tax')

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
" 
3. Now we can get these images but there are lots of duplicate sql queries, so we need to get the related fields beforehand.
** select_related is best used for "one-to-one" or "many-to-one" relationships.
** prefetch_related, on the other hand, is designed for "one-to-many" and "many-to-many" relationships.

Since we have one to many relationships, we will use prefetch_related.
** views.py
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.prefetch_related('images').all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    permission_classes = [IsAdminOrReadOnly]
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)

        return super().destroy(request, *args, **kwargs)
"

#! JWT Tokens for Authentication
{
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcyMDg4NTU0MiwiaWF0IjoxNzIwNzk5MTQyLCJqdGkiOiJlNWIwNmIzOTE0Yzc0YzE4OGM2ZDUzMzJlYjhjNzUyMyIsInVzZXJfaWQiOjF9.dsdTcrHVk6mUUycWxDgq_Vkxd4jc5zi4n9sw5vUITLM",
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzI5NDM5MTQyLCJpYXQiOjE3MjA3OTkxNDIsImp0aSI6ImNhNjU3ZTNhNmY5NjQyY2Y4YzFhZjJjZTIzMmM5ZTZlIiwidXNlcl9pZCI6MX0.KzA1Cs99loTmmm1xNx8mReiPhj5-NSfhN7a1Y9TdKzc"
}

Then add "JWT <access_token>" in your ModHeader Chrome extension. Now you can access all the protected routes.

#! Validating uploaded files
1. Create a file called "validators.py" in the "store" app
** validators.py
"
from django.core.exceptions import ValidationError

def validate_file_size(file):
    max_size_kb = 50
    
    if file.size > max_size_kb * 1024:
        raise ValidationError(f'File size should not exceed {max_size_kb} KB')
"

Now add this validator in the ProductImage model
** models.py
"
class ProductImage(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(upload_to='store/images', blank=True, null=True, validators=[validate_file_size])
"

#! Setting Up the Client App
I have uploaded the storefront3_client folder in the root directory of the project.
* Check your node version with "node -v"
* Install the dependencies with "npm install"
* Start the development server with "npm start"

#! Enabling CORS 
1. When we try to upload image from the frontend, we get error: "Could not reach the server!"
2. This is a classic CORS (Cross-Origin Resource Sharing) error.
3. This policy prevents any app hosted in domain1 to send request to apps hosted in domain2.
4. Here we are facing this issue because the client app is hosted in domain1 (8001) and the server is hosted in domain2 (8000).

5. To solve this CORS problem, we need to change some settings from the server side to allow requests from domain1 (8001).
6. We will use django python package "django-cors-headers"
Step-1: "pip install django-cors-headers"
Step-2: Add it to INSTALLED_APPS in settings.py "corsheaders"
Step-3: Add it to MIDDLEWARE in settings.py "corsheaders.middleware.CorsMiddleware"
Step-4: Add it to settings.py "CORS_ALLOWED_ORIGINS"
"
CORS_ALLOWED_ORIGINS = [
    'http://localhost:8001',
    'http://127.0.0.1:8001',
]
"

#! Managing Images in the Admin 
** media/store/styles.css 
"
.thumbnail {
    width: 100px;
    height: 100px;
    object-fit: cover;
}
"

** store/admin.py
"
class ProductImageInline(admin.TabularInline):
    model = models.ProductImage
    readonly_fields = ['thumbnail']

    def thumbnail(self, instance):
        if instance.image.name != '':
            return format_html(f'<img src="{instance.image.url}" class="thumbnail" />')
        return ''
"

** core/admin.py
"
class CustomProductAdmin(ProductAdmin):
    inlines = [TagInline, ProductImageInline]
"

#* Section - 2 (Sending Email)

#! Setting Up a fake SMTP server
1. SMTP -> Simple Mail Transfer Protocol
2. For setting up a fake SMTP server, we will use "https://github.com/rnwood/smtp4dev"
3. Check its installation page, and then we will clone the fake server using docker image 
4. run "docker run --rm -it -p 5000:80 -p 2525:25 rnwood/smtp4dev"
We will get this output:
"
PS C:\Users\CZ0258> docker run --rm -it -p 5000:80 -p 2525:25 rnwood/smtp4dev
Unable to find image 'rnwood/smtp4dev:latest' locally
latest: Pulling from rnwood/smtp4dev
09f376ebb190: Pull complete
7248743022af: Pull complete
95fcf2c5436c: Pull complete
0fbaf16568f1: Pull complete
e9e190cbc518: Pull complete
a893f927642d: Pull complete
25f219cce78d: Pull complete
Digest: sha256:912304153668068188d83b612fe0b7c4ec852dddb45fb2946895c7a72e89c6f2
Status: Downloaded newer image for rnwood/smtp4dev:latest
smtp4dev version 3.6.1+5e577a8b4152ceb7276a5b8d4432430c9ff9055d
https://github.com/rnwood/smtp4dev
.NET Core runtime version: .NET 8.0.4

 > For help use argument --help

Install location: /
DataDir: /smtp4dev
Default settings file: /app/appsettings.json
User settings file: /smtp4dev/appsettings.json
Storing keys in a directory '/root/.aspnet/DataProtection-Keys' that may not be persisted outside of the container. Protected data will be unavailable when container is destroyed. For more information go to https://aka.ms/aspnet/dataprotectionwarning
Parsing AutomaticRelayExpression
Parsing CredentialsValidationExpression
Parsing RecipientValidationExpression
Parsing MessageValidationExpression
No XML encryptor configured. Key {2276da35-cd42-4491-96d2-c05821926287} may be persisted to storage in unencrypted form.
Using Sqlite database at /smtp4dev/database.db
Updating DB schema with migrations: 20181020095712_InitialCreate, 20181021072518_AddSessionToMessageReln, 20181021105259_AddSessionStartData, 20181022132948_AddSessionErrorInfo, 20181022163054_AddAttachmentCount, 20190310130227_AddMessageUnreadFlag, 20200904135503_AddRelayError, 20200924120747_AddImapState, 20210211134331_AddMessageSecurity, 20210731045851_UTCTimeMigration, 20210807032903_MessageRelay, 20210901140449_Fix_Messages_PK, 20240308081358_AddSessionEncoding, 20240309084542_AddMessageEightBitTransport, 20240425190525_AddMailboxes, 20240511110456_AddDeliveredTo, 20240515191815_FixSessionMessageCascasing
Creating mailbox Default
TLS mode: None
SMTP Server is listening on port 25 (::).
Keeping last 100 messages per mailbox and 100 sessions.
IMAP Server is listening on port 143 (::)
Overriding HTTP_PORTS '80' and HTTPS_PORTS ''. Binding to values defined by URLS instead 'http://*:80'.
Now listening on: http://[::]:80
"
5. Now since the server is running on port 5000, we will use "http://localhost:5000" to send an email.

#! Configuring the email backend
There are various types of backends:
* SMTP (default)
* Console
* File
* Locmmem
* Dummy

1. Add the following code in settings.py
"
# EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
# EMAIL_BACKEND = 'django.core.mail.filebased.console.EmailBackend'
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'localhost'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 2525 # Check your email server terminal input command and output from NOTES_3.txt
DEFAULT_FROM_EMAIL = 'from@example.com'
"

#! Sending Emails
1. We can send mail using send_mail and mail_admins
2. We do not need to add any configuration for send_mail but for mail_admins we need to add the following code:
"
ADMINS = [
    ('admin', 'admin@gmail.com'),
]
"
3. Go to playground/views.py
"
from django.core.mail import send_mail, mail_admins, BadHeaderError
from django.shortcuts import render

def say_hello(request):
    try:
        # send_mail(subject="Django Test Email", message="Hello, this is a test email from django smtp server...", from_email="ayushdjango@gmail.com", recipient_list=["ayushsenapati123@gmail.com"])
        mail_admins(subject="Django Test Email", message="Hello, this is a test email from django smtp server...", fail_silently=False, html_message="Hello, this is a test email from django smtp server...")
    except BadHeaderError:
        pass
    return render(request, 'hello.html', {'name': 'Ayush Senapati'})
"

#! Attaching files
1. We will use EmailMessage for attaching files
** playground/views.py
"
from django.core.mail import send_mail, mail_admins, BadHeaderError, EmailMessage
from django.shortcuts import render


def say_hello(request):
    try:
        message = EmailMessage(
            subject="Django Test Email",
            body="Hello, this is a test email from django smtp server...",
            from_email="ayushdjango@gmail.com",
            to=["ayushsenapati123@gmail.com"],
        )
        message.attach_file("playground/static/images/amazon.png")
        message.send()
    except BadHeaderError:
        pass

    return render(request, "hello.html", {"name": "Ayush Senapati"})

"

#! Sending Templated Emails
1. "pip install django-templated-mail"
2. Create a new template in playground/templates/email/hello.html
"
{% block subject %}This is a long subject{% endblock %}

{% block html_body %}
<h1>Hello</h1>
My name is {{ name }}
{% endblock %}
"
3. In playground/views.py
"
from django.core.mail import EmailMessage, BadHeaderError
from django.shortcuts import render
from templated_mail.mail import BaseEmailMessage


def say_hello(request):
    try:
       message = BaseEmailMessage(
           template_name='emails/hello.html',
           context={'name': 'Ayush'}
       )
       message.send(['ayushsenapati123@gmail.com'])
    except BadHeaderError:
        pass
    return render(request, 'hello.html', {'name': 'Ayush Senapati'})
"

#* Section - 3 (Running Background Tasks)

#! Introduction to Celery

1. There are lots of long-running tasks like:
* Sending Emails
* Processing images and videos
* Generating reports
* Running machine learning models, etc.

2. With celery, we can have multiple workers working in parallel for our application.
3. Flow:
Application -> Queue -> Worker_1, Worker_2, Worker_3, etc
4. The main advantage of using Celery is that:
* we can schedule tasks to be run in the future i.e periodic tasks.
* time taking tasks can be run in the background.
* even if any worker goes down, tasks can still be run and the main application will not be blocked.

#! Message Broker
1. Flow:
Application -> Queue -> Worker_1, Worker_2, Worker_3, etc
2. Here the queue is the message broker responsible for assigning tasks along with sending and receiving messages from the workers.
3. Broker is just the middleman between the application and the workers.
4. Celery provides message broker like:
* Redis (in-memory data store)
* RabbitMQ (real, enterprise-grade broker)
5. We will use redis as our cache + message broker

#! Installing Redis
1. Here, we will use docker to install and use redis.
2. Redis will be inside a docker container which you can think of as a isolated light weight virtual machine.
3. Our application and the redis in the container will communicate using a port.
4. Use "docker run -d -p 6379:6379 redis" to run the container.
The command "docker run -d -p 6379:6379 redis" is used to start a new Docker container based on the redis image. Let's break down each part of the command to understand what it does:

** docker run: This is the basic command used to create and start a new container from an image.
** -d: The -d flag stands for "detached mode." When you run a container in detached mode, it starts in the background and doesn't receive input or display output in your terminal. This allows you to continue using the terminal while the container runs.
** -p 6379:6379: The -p flag is used to publish a container's port(s) to the host (your computer). The syntax is -p <host_port>:<container_port>. In this case, 6379:6379 means that port 6379 inside the container (the standard port for Redis) is mapped to port 6379 on your host machine. This allows you to connect to the Redis instance running inside the Docker container from any application running on your host machine that needs to communicate with Redis.
** redis: Finally, redis specifies the name of the Docker image to use when creating the container. Docker images contain the software needed to run applications. In this case, redis refers to the official Redis image available on Docker Hub, which includes the Redis server.
5. Use "docker ps" to check all the containers which are running.
"
PS D:\Ultimate-Django-Series> docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS              PORTS                    NAMES
d4f0c5014983   redis     "docker-entrypoint.sâ€¦"   About a minute ago   Up About a minute   0.0.0.0:6379->6379/tcp   laughing_mirzakhani
"
6. Also install redis as your django dependency by running: "pip install redis"

#! Celery and Windows
1. Celery 4+ and above are not supported on Windows.
2. To solve this, we will use WSL i.e Windows Subsystem for Linux.

#! Setting up Celery
1. Run "pip install celery"
2. Inside the project directory, create a new file named celery.py
** storefront/celery.py
"
import os
from celery import Celery

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'storefront.settings')

celery = Celery('storefront')
celery.config_from_object('django.conf:settings', namespace='CELERY')
celery.autodiscover_tasks()   
"
3. But for django to recognize this celery.py code, add it to __init__.py
"
from storefront.celery import celery
"
4. Add this to settings.py
** storefront/settings.py
"
# CELERY_BROKER_URL = 'redis://127.0.0.1:6379'
CELERY_BROKER_URL = 'redis://localhost:6379/1'
"

5. So, currently we need 3 commands for our application to run:
-> python manage.py runserver
-> docker run -p 6379:6379 redis
-> celery -A storefront worker --loglevel=info
6. This is where docker can be very helpful. We will use "docker-compose up" to do this. This will be implemented at the end of this project development.

#! Creating and Executing Tasks
1. Create a new file named tasks.py
** storefront/tasks.py
"
from time import sleep
from celery import shared_task

@shared_task
def notify_customers(message):
    print("Sending 10k emails to customers...")
    print(message)
    sleep(10)
    print("Emails were successfully sent!!!")
"

** storefront/views.py
"
from django.shortcuts import render
from playground.tasks import notify_customers

def say_hello(request):
    notify_customers.delay(message="Hello World")
    return render(request, 'hello.html', {'name': 'Ayush Senapati'})
"

#! Scheduling Periodic Tasks
1. Used for:
* Generating periodic tasks
* Sending emails
* Running maintenance tasks
2. We will use "celery beat" to schedule periodic tasks
3. pip install django-celery-beat
4. Add it to INSTALLED_APPS in settings.py => "django_celery_beat"
5. Add the following code to settings.py
"
CELERY_BEAT_SCHEDULE = {
    #! For better consistency, it is better to use same name as in tasks.py
    'notify_customers': {
        'task': 'playground.tasks.notify_customers',
        'schedule': 5, #! Schedule interval in seconds
        'args': ['Hello World']
    }
}
"
6. Use "celery -A storefront beat --loglevel=info" to start the celery beat
7. Use "celery -A storefront worker --loglevel=info" to start the celery worker
8. Now beat will send the periodic tasks to the worker every 5 seconds.

#! Monitoring Celery Tasks
1. For monitoring, we will use flower => pip install flower
2. Use "celery -A storefront flower"
3. Open http://localhost:5555 in your browser

4. We can also use django-celery-result => pip install django-celery-results
5. Add it to INSTALLED_APPS in settings.py => "django_celery_results"
6. Add the following code to settings.py
"
CELERY_RESULT_BACKEND = 'django-db'
"

#TODO => Major Changes
# ! Updated Celery Configuration 
** storefront/settings.py
"
CELERY_BROKER_URL = 'redis://127.0.0.1:6379' #! 6379 is the default port.
CELERY_ACCEPT_CONTENT = ['application/json']
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TASK_SERIALIZER = 'json'

CELERY_RESULT_BACKEND = 'django-db'

CELERY_BEAT_SCHEDULE = {
    #! For better consistency, it is better to use same name as in tasks.py
    'notify_customers': {
        'task': 'playground.tasks.notify_customers',
        'schedule': 5, #! Schedule interval in seconds
        'args': ['Hello World']
    }
}
"

** storefront/celery.py
"
import os
from celery import Celery
from django.conf import settings

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'storefront.settings')

celery = Celery('storefront')
celery.config_from_object(settings, namespace='CELERY')
celery.autodiscover_tasks()
"

** storefront/__init__.py
"
from storefront.celery import celery as celery_app

__all__ = ('celery_app',)
"

** playground/tasks.py
"
from time import sleep
from celery import shared_task


@shared_task(bind=True)
def test_func(self):
    # operations
    for i in range(10):
        print(i)
    return "Done"


@shared_task
def notify_customers(message):
    print("Sending 10k emails to customers...")
    print(message)
    sleep(10)
    print("Emails were successfully sent!!!")

"

** playground/views.py
"
from django.shortcuts import render
from playground.tasks import notify_customers


def say_hello(request):
    notify_customers.delay(message="Hello World")
    return render(request, 'hello.html', {'name': 'Ayush Senapati'})
"

1. Run command for worker => "celery -A storefront.celery worker --pool=solo --loglevel=info"
2. Run command for beat => "celery -A storefront.celery beat --loglevel=info"
3. Run command for flower => "celery -A storefront.celery flower"

#* Section - 4 (Automated Testing)

#! What is Automated Testing?
Automated Testing is a process of writing automated tests for your software. Manual testing is possible but as our application grows with time, manual testing will not be feasible anymore so we use automated testing.

#! Test Behaviours, Not Implementations 
1. While testing, just test the behaviour, not the implementation.
2. We check whether the fan is on or off by checking the rotation speed of the fan rather than opening the fan and checking the input and output current from the capacitors and rotors.
3. Watch the video once for some more details.

#! Tooling ( Test Frameworks )
1. Pytest (we will use this)
2. unittest

* pip install pytest
* pip install pytest-django (This is a django dependency for pytest)

#! First Test
1. Create a new folder called "tests" inside "store" directory. This folder convention is a must.
2. Inside the tests folder, create a new file named "test_collections.py". This "test_" convention is a must.
3. Create a new function inside the file named "test_collections.py". This "test_" function convention is a must.
"
from rest_framework import status
from rest_framework.test import APIClient

class TestCreateCollection():
    def test_if_user_is_anonymous_return_401(self):
        #TODO => Format for any test => AAA (Arrange, Act, Assert)
        # Arrange
        
        # Act
        client = APIClient()
        response = client.post('/store/collections/', {'title': 'some title'})
        
        # Assert
        assert response.status_code == status.HTTP_401_UNAUTHORIZED       
"

#! Running Tests
1. Create a new file in the root directory named "pytest.ini"
"
[pytest]
DJANGO_SETTINGS_MODULE = storefront.settings
"

** test_collections.py
"
from rest_framework import status
from rest_framework.test import APIClient
import pytest

@pytest.mark.django_db
class TestCreateCollection():
    def test_if_user_is_anonymous_return_401(self):
        #TODO => Format for any test => AAA (Arrange, Act, Assert)
        # Arrange
        
        # Act
        client = APIClient()
        response = client.post('/store/collections/', {'title': 'some title'})
        
        # Assert
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
"
2. Now in the terminal, run command => "pytest" to run all the tests from every app directory.
3. To run test for any individual app, run command => "pytest store/tests"
4. To run only a specific test, run command => "pytest store/tests/test_collections.py"
5. To use a particular class for testing run command => "pytest store/tests/test_collections.py::TestCreateCollection"
6. Use command "pytest -k anonymous" to run only tests that have "anonymous" in their name.

#! Skipping Test
1. To skip any test, add pytest.mark.skip
** test_collections.py
"
from rest_framework import status
from rest_framework.test import APIClient
import pytest

@pytest.mark.django_db
class TestCreateCollection():
    @pytest.mark.skip
    def test_if_user_is_anonymous_return_401(self):
        #TODO => Format for any test => AAA (Arrange, Act, Assert)
        # Arrange
        
        # Act
        client = APIClient()
        response = client.post('/store/collections/', {'title': 'some title'})
        
        # Assert
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
"

#! Continuous Testing
1. pip install pytest-watch (We will use this)
2. Now in terminal run command => "ptw", it will keep watching and run tests continuously whenever the code is changed.

#! Running and Debugging Tests in VS Code
1. Go to "Testing" tab in VS code left panel
2. Select the type of test i.e unittest or pytest
3. Select the location for the test
4. Now run the available test in VS code.

#! Authenticating the user
1. use "client.force_authenticate(user=user)" in the test function to authenticate the user.

** test_collections.py
"
from rest_framework import status
from rest_framework.test import APIClient
import pytest

@pytest.mark.django_db
class TestCreateCollection():
    def test_if_user_is_anonymous_return_401(self):
        #TODO => Format for any test => AAA (Arrange, Act, Assert)
        # Arrange
        
        # Act
        client = APIClient()
        response = client.post('/store/collections/', {'title': 'some title'})
        
        # Assert
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
        
    def test_if_user_is_not_admin_return_403(self):
        client = APIClient()
        client.force_authenticate(user = {})
        response = client.post('/store/collections/', {'title': 'some title'})
        assert response.status_code == status.HTTP_403_FORBIDDEN
"

#! Single or Multiple Assertions
1. Tests should have a single responsibility.

** test_collections.py
"
from django.contrib.auth.models import User
from rest_framework import status
from rest_framework.test import APIClient
import pytest

@pytest.mark.django_db
class TestCreateCollection():
    def test_if_user_is_anonymous_return_401(self):
        #TODO => Format for any test => AAA (Arrange, Act, Assert)
        # Arrange
        
        # Act
        client = APIClient()
        response = client.post('/store/collections/', {'title': 'some title'})
        
        # Assert
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
        
    def test_if_user_is_not_admin_return_403(self):
        client = APIClient()
        client.force_authenticate(user = {})
        response = client.post('/store/collections/', {'title': 'some title'})
        assert response.status_code == status.HTTP_403_FORBIDDEN
        
    def test_if_data_is_invalid_returns_400(self):
        client = APIClient()
        client.force_authenticate(user=User(is_staff=True))
        response = client.post('/store/collections/', {'title': ''})
        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert response.data['title'] is not None
        
    def test_if_data_is_valid_returns_201(self):
        client = APIClient()
        client.force_authenticate(user=User(is_staff=True))
        response = client.post('/store/collections/', {'title': 'some title'})
        assert response.status_code == status.HTTP_201_CREATED
        assert response.data['id'] > 0
"

#! Fixtures
1. Feature of pytest which can be used to remove the repetition of code.
2. Create a fixture in conftest.py under tests folder
3. These fixtures will be available in all the tests even without importing explicitly.
** conftest.py
"
import pytest
from rest_framework.test import APIClient
from django.contrib.auth.models import User

@pytest.fixture
def api_client():
    return APIClient()

@pytest.fixture
def authenticate(api_client):
    def do_authenticate(is_staff=False):
        return api_client.force_authenticate(user=User(is_staff=is_staff))
    return do_authenticate
"
** test_collections.py
"
from django.contrib.auth.models import User
from rest_framework import status
from rest_framework.test import APIClient
import pytest


@pytest.fixture
def create_collection(api_client):
    def do_create_collection(collection):
        return api_client.post("/store/collections/", collection)

    return do_create_collection


@pytest.mark.django_db
class TestCreateCollection:
    def test_if_user_is_anonymous_returns_401(self, create_collection):
        response = create_collection({"title": "a"})

        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    def test_if_user_is_not_admin_returns_403(self, authenticate, create_collection):
        #! Arrange
        authenticate()
        #! Act
        response = create_collection({"title": "a"})
        #! Assert
        assert response.status_code == status.HTTP_403_FORBIDDEN

    def test_if_data_is_invalid_returns_400(self, authenticate, create_collection):
        authenticate(is_staff=True)

        response = create_collection({"title": ""})

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert response.data["title"] is not None

    def test_if_data_is_valid_returns_201(self, authenticate, create_collection):
        authenticate(is_staff=True)

        response = create_collection({"title": "a"})

        assert response.status_code == status.HTTP_201_CREATED
        assert response.data["id"] > 0
"

#! Creating Model Instances
Our previous tests were related to creating instances but now we will be creating model instances to retrieve data from the database.
1. pip install model_bakery
2. Model Bakery will create a dummy db just for testing at the starting of each test and drop it after the test is completed.
** test_collections.py
"
from django.contrib.auth.models import User
from rest_framework import status
from rest_framework.test import APIClient
import pytest
from model_bakery import baker
from store.models import Collection


@pytest.fixture
def create_collection(api_client):
    def do_create_collection(collection):
        return api_client.post("/store/collections/", collection)

    return do_create_collection


@pytest.mark.django_db
class TestCreateCollection:
    def test_if_user_is_anonymous_returns_401(self, create_collection):
        response = create_collection({"title": "a"})

        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    def test_if_user_is_not_admin_returns_403(self, authenticate, create_collection):
        #! Arrange
        authenticate()
        #! Act
        response = create_collection({"title": "a"})
        #! Assert
        assert response.status_code == status.HTTP_403_FORBIDDEN

    def test_if_data_is_invalid_returns_400(self, authenticate, create_collection):
        authenticate(is_staff=True)

        response = create_collection({"title": ""})

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert response.data["title"] is not None

    def test_if_data_is_valid_returns_201(self, authenticate, create_collection):
        authenticate(is_staff=True)

        response = create_collection({"title": "a"})

        assert response.status_code == status.HTTP_201_CREATED
        assert response.data["id"] > 0


@pytest.mark.django_db
class TestRetrieveCollection:
    def test_if_collection_exists_returns_200(self, api_client):
        #! Arrange
        collection = baker.make(Collection)
        #! Act
        response = api_client.get(f'/store/collections/{collection.id}/')

        assert response.status_code == status.HTTP_200_OK
        assert response.data == {
            'id': collection.id,
            'title': collection.title,
            'products_count': 0
        }
"

#* Section - 5 ( Performance Testing )

#! Why Performance Testing?
1. To test and measure the performance of the application.
2. Most companies neglect performance testing but later on face huge issues like application crash etc.
3. Always run performance tests while building an application.
4. Helps us identify and fix performance issues.

#! Installing Locust
There are various performance testing tools but we will use Locust.
1. pip install locust

#! Creating a Test Script
Core Use Cases - 
* Browse products
* Register, sign in and sign out

1. Create a new directory called "locustfiles"
2. Inside that directory, create a new file called "browse_products.py"
3. Write your load tests in that file.
** browse_products.py
"
from locust import HttpUser, task, between
from random import randint

class WebsiteUser(HttpUser):
    #TODO -> * Viewing products * Viewing product details * Add product to cart
    
    #! This will make the tasks wait between 1 and 5 seconds before executing the next task
    wait_time = between(1, 5)
    
    #! This task numbers are weight of each task i.e their priority
    #! Higher number means higher priority
    @task(2)
    def view_products(self):
        print("View products")
        collection_id = randint(2, 6)
        self.client.get(f"/store/products/?collection_id={collection_id}", name="/store/products")

    @task(4) 
    def view_product_details(self):
        print("View product details")
        product_id = randint(1, 1000)
        self.client.get(f"/store/products/{product_id}", name="/store/products/:id")

    @task(1)
    def add_to_cart(self):
        print("Add to cart")
        product_id = randint(1, 10)
        self.client.post(f"/store/carts/{self.cart_id}/items/", name="/store/carts/items/", json={'product_id': product_id, 'quantity': 1})

    #! This is not a task but will run on start of every load test
    def on_start(self):
        response = self.client.post("/store/carts/")
        result = response.json()
        self.cart_id = result["id"]
"

#! Running a load test script
1. In terminal, run command => "locust -f locustfiles/browse_products.py", you will see terminal output like
"
Ultimate Django Series 3> locust -f .\locustfiles\browse_products.py
[2024-07-16 13:00:34,893] INFO/locust.main: Starting web interface at http://localhost:8089 (accepting connections from all network interfaces)
[2024-07-16 13:00:34,932] INFO/locust.main: Starting Locust 2.29.1
"
2. Now in the locust webpage, set 
* Number of users = 1
* Ramp up = 1
* Host = http://localhost:8000
and click on "Start" button.

#! Performance Testing Optimization
1. Optimize the code, remove unnecessary code, etc. Refer "tips.txt"
2. Re-write the query
3. Tune the database
4. Cache the results

#! Profiling with Silk
Now that we have identified the slow endpoints, we will now have to identify the source of the issue. For this, we will use "Silk".
1. pip install django-silk
2. Add it to INSTALLED_APPS in settings.py => "silk"
3. Add it to MIDDLEWARE in settings.py => "silk.middleware.SilkyMiddleware"
"
if DEBUG:
    MIDDLEWARE += [
        'silk.middleware.SilkyMiddleware',
    ]
"
4. Add it to urls.py => urlpatterns += [path('silk/', include('silk.urls', namespace='silk'))] inside the settings.DEBUG
"
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
    urlpatterns += [path('silk/', include('silk.urls', namespace='silk'))]
"
5. Now run migration command => "python manage.py migrate"
6. Now go to "127.0.0.1:8000/silk/", you will see the dashboard. You can access every detail of the endpoints along with the sql queries running in the background with its execution time.

#! Verifying Optimizations
1. Rerun the locust performance test after making Optimizations and also comment out the Silk middleware as it adds a lot of overhead.

#! Stress Testing
1. Load test your application with around 1000 users.