#! Setting Up the Project and Database
1. Open MySQL Workbench and create a new database named storefront3.
2. Run "python manage.py makemigrations" and "python manage.py migrate" to create the tables in the database.
3. Now rather than using the seed.sql directly to import the data in the database using the SQL Workbench, we will use a custom command.
4. Create a custom command named "seed_db" my creating a management folder followed by a commands folder inside the store app. 
5. Write the following code in seed_db.py and place seed.sql file in the same directory.
"
#! CUSTOM COMMAND TO POPULATE THE DATABASE
from django.core.management.base import BaseCommand
from django.db import connection
from pathlib import Path
import os


class Command(BaseCommand):
    help = 'Populates the database with collections and products'

    def handle(self, *args, **options):
        print('Populating the database...')
        current_dir = os.path.dirname(__file__)
        file_path = os.path.join(current_dir, 'seed.sql')
        sql = Path(file_path).read_text()

        with connection.cursor() as cursor:
            cursor.execute(sql)

"
6. Now in the terminal, just type "python manage.py", we will see this output::
"
(venv) PS D:\Ultimate-Django-Series\Ultimate Django Series 3> python .\manage.py

Type 'manage.py help <subcommand>' for help on a specific subcommand.

Available subcommands:

[auth]
    changepassword
    createsuperuser

[contenttypes]
    remove_stale_contenttypes

[debug_toolbar]
    debugsqlshell

[django]
    check
    compilemessages
    createcachetable
    dbshell
    diffsettings
    flush
    inspectdb
    loaddata
    makemessages
    makemigrations
    migrate
    optimizemigration
    sendtestemail
    shell
    showmigrations
    sqlflush
    sqlmigrate
    sqlsequencereset
    squashmigrations
    startapp
    startproject
    test
    testserver

[rest_framework]
    generateschema

[sessions]
    clearsessions

[staticfiles]
    collectstatic
    findstatic
    runserver

[store]
    seed_db
"
7. Now run the "python manage.py seed_db" command to populate the database.

#* Overview
1. Uploading Files
2. Sending emails
3. Running Background Tasks
4. Automated testing
5. Performance testing
6. Caching, etc.

#* Section - 1 (Uploading Files)

#! Managing Media Files 
1. Create a "media" folder in the root directory of the project.
2. Imsert any image in the media folder.
3. Add MEDIA_URL and MEDIA_ROOT to settings.py.
"
MEDIA_URL = '/media/'
# MEDIA_ROOT = BASE_DIR / 'media'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
"
4. Add these to urls.py of the project directory.
"
from django.conf import settings
from django.conf.urls.static import static
from django.contrib import admin
from django.urls import path, include
import debug_toolbar

admin.site.site_header = "Storefront Admin"
admin.site.index_title = "Admin"

urlpatterns = [
    path("admin/", admin.site.urls),
    path("playground/", include("playground.urls")),
    path("store/", include("store.urls")),
    path("auth/", include("djoser.urls")),
    path("auth/", include("djoser.urls.jwt")),
    path("__debug__/", include(debug_toolbar.urls)),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
"
5. Now go to "127.0.0.1:8000/media/{image.png}" and you will see the image in the browser. 

#! Adding Images to Products
1. Create a fact table for Product table which will be a one to many relationship (Product)(1) -> (Image)(n)
2. Add the following model in models.py
"
class ProductImage(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(upload_to='store/images', blank=True, null=True)
"
#! Building an API to Upload Images 
1. Now we will create a API with url like "/products/1/images/1"
Step-1: Create a serializer
Step-2: Create a viewset
Step-3: Create a router

** serializers.py
"
class ProductImageSerializer(serializers.ModelSerializer):
    def create(self, validated_data):
        product_id = self.context['product_id']
        return ProductImage.objects.create(product_id=product_id, **validated_data)
    class Meta:
        model = ProductImage
        fields = ['id', 'image']
"
** views.py
"
class ProductImageViewSet(ModelViewSet):
    serializer_class = ProductImageSerializer
    # queryset = ProductImage.objects.all()
    
    def get_serializer_context(self):
        return {'product_id': self.kwargs['product_pk']}
    
    #! URL like "/products/1(product_pk)/images/1(pk)"
    def get_queryset(self):
        return ProductImage.objects.filter(product_id=self.kwargs['product_pk'])
"
** urls.py
"
products_router.register('images', views.ProductImageViewSet, basename='product-images')
"

Now the urlpatterns looks like this:
"
[<URLPattern '^products/$' [name='products-list']>,
 <URLPattern '^products\.(?P<format>[a-z0-9]+)/?$' [name='products-list']>,
 <URLPattern '^products/(?P<pk>[^/.]+)/$' [name='products-detail']>,
 <URLPattern '^products/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='products-detail']>,
 <URLPattern '^collections/$' [name='collection-list']>,
 <URLPattern '^collections\.(?P<format>[a-z0-9]+)/?$' [name='collection-list']>,
 <URLPattern '^collections/(?P<pk>[^/.]+)/$' [name='collection-detail']>,
 <URLPattern '^collections/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='collection-detail']>,
 <URLPattern '^carts/$' [name='cart-list']>,
 <URLPattern '^carts\.(?P<format>[a-z0-9]+)/?$' [name='cart-list']>,
 <URLPattern '^carts/(?P<pk>[^/.]+)/$' [name='cart-detail']>,
 <URLPattern '^carts/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='cart-detail']>,
 <URLPattern '^customers/$' [name='customer-list']>,
 <URLPattern '^customers\.(?P<format>[a-z0-9]+)/?$' [name='customer-list']>,
 <URLPattern '^customers/me/$' [name='customer-me']>,
 <URLPattern '^customers/me\.(?P<format>[a-z0-9]+)/?$' [name='customer-me']>,
 <URLPattern '^customers/(?P<pk>[^/.]+)/$' [name='customer-detail']>,
 <URLPattern '^customers/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='customer-detail']>,
 <URLPattern '^customers/(?P<pk>[^/.]+)/history/$' [name='customer-history']>,
 <URLPattern '^customers/(?P<pk>[^/.]+)/history\.(?P<format>[a-z0-9]+)/?$' [name='customer-history']>,
 <URLPattern '^orders/$' [name='orders-list']>,
 <URLPattern '^orders\.(?P<format>[a-z0-9]+)/?$' [name='orders-list']>,
 <URLPattern '^orders/(?P<pk>[^/.]+)/$' [name='orders-detail']>,
 <URLPattern '^orders/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='orders-detail']>,
 <URLPattern '' [name='api-root']>,
 <URLPattern '<drf_format_suffix:format>' [name='api-root']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/reviews/$' [name='product-reviews-list']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/reviews\.(?P<format>[a-z0-9]+)/?$' [name='product-reviews-list']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/reviews/(?P<pk>[^/.]+)/$' [name='product-reviews-detail']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/reviews/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='product-reviews-detail']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/images/$' [name='product-images-list']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/images\.(?P<format>[a-z0-9]+)/?$' [name='product-images-list']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/images/(?P<pk>[^/.]+)/$' [name='product-images-detail']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/images/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='product-images-detail']>,
 <URLPattern '' [name='api-root']>,
 <URLPattern '<drf_format_suffix:format>' [name='api-root']>,
 <URLPattern '^carts/(?P<cart_pk>[^/.]+)/items/$' [name='cart-items-list']>,
 <URLPattern '^carts/(?P<cart_pk>[^/.]+)/items\.(?P<format>[a-z0-9]+)/?$' [name='cart-items-list']>,
 <URLPattern '^carts/(?P<cart_pk>[^/.]+)/items/(?P<pk>[^/.]+)/$' [name='cart-items-detail']>,
 <URLPattern '^carts/(?P<cart_pk>[^/.]+)/items/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='cart-items-detail']>,
 <URLPattern '' [name='api-root']>,
 <URLPattern '<drf_format_suffix:format>' [name='api-root']>]
"

#! Returning Images from the Product API
1. We need images to be returned in the Product API
2. Add images to the ProductSerializer
** serializer.py
"
class ProductImageSerializer(serializers.ModelSerializer):
    def create(self, validated_data):
        product_id = self.context['product_id']
        return ProductImage.objects.create(product_id=product_id, **validated_data)
    class Meta:
        model = ProductImage
        fields = ['id', 'image']

class ProductSerializer(serializers.ModelSerializer):
    images = ProductImageSerializer(many=True, read_only=True)
    class Meta:
        model = Product
        fields = ['id', 'title', 'description', 'slug', 'inventory',
                  'unit_price', 'price_with_tax', 'collection', 'images']

    price_with_tax = serializers.SerializerMethodField(
        method_name='calculate_tax')

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
" 
3. Now we can get these images but there are lots of duplicate sql queries, so we need to get the related fields beforehand.
** select_related is best used for "one-to-one" or "many-to-one" relationships.
** prefetch_related, on the other hand, is designed for "one-to-many" and "many-to-many" relationships.

Since we have one to many relationships, we will use prefetch_related.
** views.py
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.prefetch_related('images').all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    permission_classes = [IsAdminOrReadOnly]
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)

        return super().destroy(request, *args, **kwargs)
"

#! JWT Tokens for Authentication
{
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcyMDA4NjgxNCwiaWF0IjoxNzIwMDAwNDE0LCJqdGkiOiI2MjFlYmJjMDJiMTU0NDc2YjMyZDlmYTNmZDQ2ODllOCIsInVzZXJfaWQiOjF9.X7QcxJcHdE_ZGW_AtES_YTAjEHK9otUfEnrmR9tuCMI",
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzIwMDg2ODE0LCJpYXQiOjE3MjAwMDA0MTQsImp0aSI6IjI5ZDIyMDk5MDg3NjRhNmY5NGVlZjZiYTBmOWYyYWMzIiwidXNlcl9pZCI6MX0.dppHRTj3zuhgW0HoETEkiCBKY1ojq-hSA8RBn1TiHLw"
}

Then add "JWT <access_token>" in your ModHeader Chrome extension. Now you can access all the protected routes.

#! Validating uploaded files
1. Create a file called "validators.py" in the "store" app
** validators.py
"
from django.core.exceptions import ValidationError

def validate_file_size(file):
    max_size_kb = 50
    
    if file.size > max_size_kb * 1024:
        raise ValidationError(f'File size should not exceed {max_size_kb} KB')
"

Now add this validator in the ProductImage model
** models.py
"
class ProductImage(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(upload_to='store/images', blank=True, null=True, validators=[validate_file_size])
"

#! Setting Up the Client App
I have uploaded the storefront3_client folder in the root directory of the project.
* Check your node version with "node -v"
* Install the dependencies with "npm install"
* Start the development server with "npm start"

#! Enabling CORS 
1. When we try to upload image from the frontend, we get error: "Could not reach the server!"
2. This is a classic CORS (Cross-Origin Resource Sharing) error.
3. This policy prevents any app hosted in domain1 to send request to apps hosted in domain2.
4. Here we are facing this issue because the client app is hosted in domain1 (8001) and the server is hosted in domain2 (8000).

5. To solve this CORS problem, we need to change some settings from the server side to allow requests from domain1 (8001).
6. We will use django python package "django-cors-headers"
Step-1: "pip install django-cors-headers"
Step-2: Add it to INSTALLED_APPS in settings.py "corsheaders"
Step-3: Add it to MIDDLEWARE in settings.py "corsheaders.middleware.CorsMiddleware"
Step-4: Add it to settings.py "CORS_ALLOWED_ORIGINS"
"
CORS_ALLOWED_ORIGINS = [
    'http://localhost:8001',
    'http://127.0.0.1:8001',
]
"

#! Managing Images in the Admin 
** media/store/styles.css 
"
.thumbnail {
    width: 100px;
    height: 100px;
    object-fit: cover;
}
"

** store/admin.py
"
class ProductImageInline(admin.TabularInline):
    model = models.ProductImage
    readonly_fields = ['thumbnail']

    def thumbnail(self, instance):
        if instance.image.name != '':
            return format_html(f'<img src="{instance.image.url}" class="thumbnail" />')
        return ''
"

** core/admin.py
"
class CustomProductAdmin(ProductAdmin):
    inlines = [TagInline, ProductImageInline]
"

#* Section - 2 (Sending Email)

#! Setting Up a fake SMTP server
1. SMTP -> Simple Mail Transfer Protocol
2. For setting up a fake SMTP server, we will use "https://github.com/rnwood/smtp4dev"
3. Check its installation page, and then we will clone the fake server using docker image 
4. run "docker run --rm -it -p 5000:80 -p 2525:25 rnwood/smtp4dev"
We will get this output:
"
PS C:\Users\CZ0258> docker run --rm -it -p 5000:80 -p 2525:25 rnwood/smtp4dev
Unable to find image 'rnwood/smtp4dev:latest' locally
latest: Pulling from rnwood/smtp4dev
09f376ebb190: Pull complete
7248743022af: Pull complete
95fcf2c5436c: Pull complete
0fbaf16568f1: Pull complete
e9e190cbc518: Pull complete
a893f927642d: Pull complete
25f219cce78d: Pull complete
Digest: sha256:912304153668068188d83b612fe0b7c4ec852dddb45fb2946895c7a72e89c6f2
Status: Downloaded newer image for rnwood/smtp4dev:latest
smtp4dev version 3.6.1+5e577a8b4152ceb7276a5b8d4432430c9ff9055d
https://github.com/rnwood/smtp4dev
.NET Core runtime version: .NET 8.0.4

 > For help use argument --help

Install location: /
DataDir: /smtp4dev
Default settings file: /app/appsettings.json
User settings file: /smtp4dev/appsettings.json
Storing keys in a directory '/root/.aspnet/DataProtection-Keys' that may not be persisted outside of the container. Protected data will be unavailable when container is destroyed. For more information go to https://aka.ms/aspnet/dataprotectionwarning
Parsing AutomaticRelayExpression
Parsing CredentialsValidationExpression
Parsing RecipientValidationExpression
Parsing MessageValidationExpression
No XML encryptor configured. Key {2276da35-cd42-4491-96d2-c05821926287} may be persisted to storage in unencrypted form.
Using Sqlite database at /smtp4dev/database.db
Updating DB schema with migrations: 20181020095712_InitialCreate, 20181021072518_AddSessionToMessageReln, 20181021105259_AddSessionStartData, 20181022132948_AddSessionErrorInfo, 20181022163054_AddAttachmentCount, 20190310130227_AddMessageUnreadFlag, 20200904135503_AddRelayError, 20200924120747_AddImapState, 20210211134331_AddMessageSecurity, 20210731045851_UTCTimeMigration, 20210807032903_MessageRelay, 20210901140449_Fix_Messages_PK, 20240308081358_AddSessionEncoding, 20240309084542_AddMessageEightBitTransport, 20240425190525_AddMailboxes, 20240511110456_AddDeliveredTo, 20240515191815_FixSessionMessageCascasing
Creating mailbox Default
TLS mode: None
SMTP Server is listening on port 25 (::).
Keeping last 100 messages per mailbox and 100 sessions.
IMAP Server is listening on port 143 (::)
Overriding HTTP_PORTS '80' and HTTPS_PORTS ''. Binding to values defined by URLS instead 'http://*:80'.
Now listening on: http://[::]:80
"
5. Now since the server is running on port 5000, we will use "http://localhost:5000" to send an email.

#! Configuring the email backend
There are various types of backends:
* SMTP (default)
* Console
* File
* Locmmem
* Dummy

1. Add the following code in settings.py
"
# EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
# EMAIL_BACKEND = 'django.core.mail.filebased.console.EmailBackend'
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'localhost'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 2525 # Check your email server terminal input command and output from NOTES_3.txt
DEFAULT_FROM_EMAIL = 'from@example.com'
"

#! Sending Emails
1. We can send mail using send_mail and mail_admins
2. We do not need to add any configuration for send_mail but for mail_admins we need to add the following code:
"
ADMINS = [
    ('admin', 'admin@gmail.com'),
]
"
3. Go to playground/views.py
"
from django.core.mail import send_mail, mail_admins, BadHeaderError
from django.shortcuts import render

def say_hello(request):
    try:
        # send_mail(subject="Django Test Email", message="Hello, this is a test email from django smtp server...", from_email="ayushdjango@gmail.com", recipient_list=["ayushsenapati123@gmail.com"])
        mail_admins(subject="Django Test Email", message="Hello, this is a test email from django smtp server...", fail_silently=False, html_message="Hello, this is a test email from django smtp server...")
    except BadHeaderError:
        pass
    return render(request, 'hello.html', {'name': 'Ayush Senapati'})
"

#! Attaching files
1. We will use EmailMessage for attaching files
** playground/views.py
"
from django.core.mail import send_mail, mail_admins, BadHeaderError, EmailMessage
from django.shortcuts import render


def say_hello(request):
    try:
        message = EmailMessage(
            subject="Django Test Email",
            body="Hello, this is a test email from django smtp server...",
            from_email="ayushdjango@gmail.com",
            to=["ayushsenapati123@gmail.com"],
        )
        message.attach_file("playground/static/images/amazon.png")
        message.send()
    except BadHeaderError:
        pass

    return render(request, "hello.html", {"name": "Ayush Senapati"})

"

#! Sending Templated Emails
1. "pip install django-templated-mail"
2. Create a new template in playground/templates/email/hello.html
"
{% block subject %}This is a long subject{% endblock %}

{% block html_body %}
<h1>Hello</h1>
My name is {{ name }}
{% endblock %}
"
3. In playground/views.py
"
from django.core.mail import EmailMessage, BadHeaderError
from django.shortcuts import render
from templated_mail.mail import BaseEmailMessage


def say_hello(request):
    try:
       message = BaseEmailMessage(
           template_name='emails/hello.html',
           context={'name': 'Ayush'}
       )
       message.send(['ayushsenapati123@gmail.com'])
    except BadHeaderError:
        pass
    return render(request, 'hello.html', {'name': 'Ayush Senapati'})
"

#* Section - 3 (Running Background Tasks)

#! Introduction to Celery

1. There are lots of long-running tasks like:
* Sending Emails
* Processing images and videos
* Generating reports
* Running machine learning models, etc.

2. With celery, we can have multiple workers working in parallel for our application.
3. Flow:
Application -> Queue -> Worker_1, Worker_2, Worker_3, etc
4. The main advantage of using Celery is that:
* we can schedule tasks to be run in the future i.e periodic tasks.
* time taking tasks can be run in the background.
* even if any worker goes down, tasks can still be run and the main application will not be blocked.

#! Message Broker
1. Flow:
Application -> Queue -> Worker_1, Worker_2, Worker_3, etc
2. Here the queue is the message broker responsible for assigning tasks along with sending and receiving messages from the workers.
3. Broker is just the middleman between the application and the workers.
4. Celery provides message broker like:
* Redis (in-memory data store)
* RabbitMQ (real, enterprise-grade broker)
5. We will use redis as our cache + message broker

#! Installing Redis
1. Here, we will use docker to install and use redis.
2. Redis will be inside a docker container which you can think of as a isolated light weight virtual machine.
3. Our application and the redis in the container will communicate using a port.
4. Use "docker run -d -p 6379:6379 redis" to run the container.
The command "docker run -d -p 6379:6379 redis" is used to start a new Docker container based on the redis image. Let's break down each part of the command to understand what it does:

** docker run: This is the basic command used to create and start a new container from an image.
** -d: The -d flag stands for "detached mode." When you run a container in detached mode, it starts in the background and doesn't receive input or display output in your terminal. This allows you to continue using the terminal while the container runs.
** -p 6379:6379: The -p flag is used to publish a container's port(s) to the host (your computer). The syntax is -p <host_port>:<container_port>. In this case, 6379:6379 means that port 6379 inside the container (the standard port for Redis) is mapped to port 6379 on your host machine. This allows you to connect to the Redis instance running inside the Docker container from any application running on your host machine that needs to communicate with Redis.
** redis: Finally, redis specifies the name of the Docker image to use when creating the container. Docker images contain the software needed to run applications. In this case, redis refers to the official Redis image available on Docker Hub, which includes the Redis server.
5. Use "docker ps" to check all the containers which are running.
"
PS D:\Ultimate-Django-Series> docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS              PORTS                    NAMES
d4f0c5014983   redis     "docker-entrypoint.s…"   About a minute ago   Up About a minute   0.0.0.0:6379->6379/tcp   laughing_mirzakhani
"
6. Also install redis as your django dependency by running: "pip install redis"

#! Celery and Windows
1. Celery 4+ and above are not supported on Windows.
2. To solve this, we will use WSL i.e Windows Subsystem for Linux.

#! Setting up Celery
1. Run "pip install celery"
2. Inside the project directory, create a new file named celery.py
** storefront/celery.py
"
import os
from celery import Celery

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'storefront.settings')

celery = Celery('storefront')
celery.config_from_object('django.conf:settings', namespace='CELERY')
celery.autodiscover_tasks()   
"
3. But for django to recognize this celery.py code, add it to __init__.py
"
from storefront.celery import celery
"
4. Add this to settings.py
** storefront/settings.py
"
# CELERY_BROKER_URL = 'redis://127.0.0.1:6379'
CELERY_BROKER_URL = 'redis://localhost:6379/1'
"

5. So, currently we need 3 commands for our application to run:
-> python manage.py runserver
-> docker run -p 6379:6379 redis
-> celery -A storefront worker --loglevel=info
6. This is where docker can be very helpful. We will use "docker-compose up" to do this. This will be implemented at the end of this project development.