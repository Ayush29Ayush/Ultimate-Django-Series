#! Setting Up the Project and Database
1. Open MySQL Workbench and create a new database named storefront3.
2. Run "python manage.py makemigrations" and "python manage.py migrate" to create the tables in the database.
3. Now rather than using the seed.sql directly to import the data in the database using the SQL Workbench, we will use a custom command.
4. Create a custom command named "seed_db" my creating a management folder followed by a commands folder inside the store app. 
5. Write the following code in seed_db.py and place seed.sql file in the same directory.
"
#! CUSTOM COMMAND TO POPULATE THE DATABASE
from django.core.management.base import BaseCommand
from django.db import connection
from pathlib import Path
import os


class Command(BaseCommand):
    help = 'Populates the database with collections and products'

    def handle(self, *args, **options):
        print('Populating the database...')
        current_dir = os.path.dirname(__file__)
        file_path = os.path.join(current_dir, 'seed.sql')
        sql = Path(file_path).read_text()

        with connection.cursor() as cursor:
            cursor.execute(sql)

"
6. Now in the terminal, just type "python manage.py", we will see this output::
"
(venv) PS D:\Ultimate-Django-Series\Ultimate Django Series 3> python .\manage.py

Type 'manage.py help <subcommand>' for help on a specific subcommand.

Available subcommands:

[auth]
    changepassword
    createsuperuser

[contenttypes]
    remove_stale_contenttypes

[debug_toolbar]
    debugsqlshell

[django]
    check
    compilemessages
    createcachetable
    dbshell
    diffsettings
    flush
    inspectdb
    loaddata
    makemessages
    makemigrations
    migrate
    optimizemigration
    sendtestemail
    shell
    showmigrations
    sqlflush
    sqlmigrate
    sqlsequencereset
    squashmigrations
    startapp
    startproject
    test
    testserver

[rest_framework]
    generateschema

[sessions]
    clearsessions

[staticfiles]
    collectstatic
    findstatic
    runserver

[store]
    seed_db
"
7. Now run the "python manage.py seed_db" command to populate the database.

#* Overview
1. Uploading Files
2. Sending emails
3. Running Background Tasks
4. Automated testing
5. Performance testing
6. Caching, etc.

#* Section - 1 (Uploading Files)

#! Managing Media Files 
1. Create a "media" folder in the root directory of the project.
2. Imsert any image in the media folder.
3. Add MEDIA_URL and MEDIA_ROOT to settings.py.
"
MEDIA_URL = '/media/'
# MEDIA_ROOT = BASE_DIR / 'media'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
"
4. Add these to urls.py of the project directory.
"
from django.conf import settings
from django.conf.urls.static import static
from django.contrib import admin
from django.urls import path, include
import debug_toolbar

admin.site.site_header = "Storefront Admin"
admin.site.index_title = "Admin"

urlpatterns = [
    path("admin/", admin.site.urls),
    path("playground/", include("playground.urls")),
    path("store/", include("store.urls")),
    path("auth/", include("djoser.urls")),
    path("auth/", include("djoser.urls.jwt")),
    path("__debug__/", include(debug_toolbar.urls)),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
"
5. Now go to "127.0.0.1:8000/media/{image.png}" and you will see the image in the browser. 

#! Adding Images to Products
1. Create a fact table for Product table which will be a one to many relationship (Product)(1) -> (Image)(n)
2. Add the following model in models.py
"
class ProductImage(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(upload_to='store/images', blank=True, null=True)
"
#! Building an API to Upload Images 
1. Now we will create a API with url like "/products/1/images/1"
Step-1: Create a serializer
Step-2: Create a viewset
Step-3: Create a router

** serializers.py
"
class ProductImageSerializer(serializers.ModelSerializer):
    def create(self, validated_data):
        product_id = self.context['product_id']
        return ProductImage.objects.create(product_id=product_id, **validated_data)
    class Meta:
        model = ProductImage
        fields = ['id', 'image']
"
** views.py
"
class ProductImageViewSet(ModelViewSet):
    serializer_class = ProductImageSerializer
    # queryset = ProductImage.objects.all()
    
    def get_serializer_context(self):
        return {'product_id': self.kwargs['product_pk']}
    
    #! URL like "/products/1(product_pk)/images/1(pk)"
    def get_queryset(self):
        return ProductImage.objects.filter(product_id=self.kwargs['product_pk'])
"
** urls.py
"
products_router.register('images', views.ProductImageViewSet, basename='product-images')
"

Now the urlpatterns looks like this:
"
[<URLPattern '^products/$' [name='products-list']>,
 <URLPattern '^products\.(?P<format>[a-z0-9]+)/?$' [name='products-list']>,
 <URLPattern '^products/(?P<pk>[^/.]+)/$' [name='products-detail']>,
 <URLPattern '^products/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='products-detail']>,
 <URLPattern '^collections/$' [name='collection-list']>,
 <URLPattern '^collections\.(?P<format>[a-z0-9]+)/?$' [name='collection-list']>,
 <URLPattern '^collections/(?P<pk>[^/.]+)/$' [name='collection-detail']>,
 <URLPattern '^collections/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='collection-detail']>,
 <URLPattern '^carts/$' [name='cart-list']>,
 <URLPattern '^carts\.(?P<format>[a-z0-9]+)/?$' [name='cart-list']>,
 <URLPattern '^carts/(?P<pk>[^/.]+)/$' [name='cart-detail']>,
 <URLPattern '^carts/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='cart-detail']>,
 <URLPattern '^customers/$' [name='customer-list']>,
 <URLPattern '^customers\.(?P<format>[a-z0-9]+)/?$' [name='customer-list']>,
 <URLPattern '^customers/me/$' [name='customer-me']>,
 <URLPattern '^customers/me\.(?P<format>[a-z0-9]+)/?$' [name='customer-me']>,
 <URLPattern '^customers/(?P<pk>[^/.]+)/$' [name='customer-detail']>,
 <URLPattern '^customers/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='customer-detail']>,
 <URLPattern '^customers/(?P<pk>[^/.]+)/history/$' [name='customer-history']>,
 <URLPattern '^customers/(?P<pk>[^/.]+)/history\.(?P<format>[a-z0-9]+)/?$' [name='customer-history']>,
 <URLPattern '^orders/$' [name='orders-list']>,
 <URLPattern '^orders\.(?P<format>[a-z0-9]+)/?$' [name='orders-list']>,
 <URLPattern '^orders/(?P<pk>[^/.]+)/$' [name='orders-detail']>,
 <URLPattern '^orders/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='orders-detail']>,
 <URLPattern '' [name='api-root']>,
 <URLPattern '<drf_format_suffix:format>' [name='api-root']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/reviews/$' [name='product-reviews-list']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/reviews\.(?P<format>[a-z0-9]+)/?$' [name='product-reviews-list']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/reviews/(?P<pk>[^/.]+)/$' [name='product-reviews-detail']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/reviews/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='product-reviews-detail']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/images/$' [name='product-images-list']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/images\.(?P<format>[a-z0-9]+)/?$' [name='product-images-list']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/images/(?P<pk>[^/.]+)/$' [name='product-images-detail']>,
 <URLPattern '^products/(?P<product_pk>[^/.]+)/images/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='product-images-detail']>,
 <URLPattern '' [name='api-root']>,
 <URLPattern '<drf_format_suffix:format>' [name='api-root']>,
 <URLPattern '^carts/(?P<cart_pk>[^/.]+)/items/$' [name='cart-items-list']>,
 <URLPattern '^carts/(?P<cart_pk>[^/.]+)/items\.(?P<format>[a-z0-9]+)/?$' [name='cart-items-list']>,
 <URLPattern '^carts/(?P<cart_pk>[^/.]+)/items/(?P<pk>[^/.]+)/$' [name='cart-items-detail']>,
 <URLPattern '^carts/(?P<cart_pk>[^/.]+)/items/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='cart-items-detail']>,
 <URLPattern '' [name='api-root']>,
 <URLPattern '<drf_format_suffix:format>' [name='api-root']>]
"

#! Returning Images from the Product API
1. We need images to be returned in the Product API
2. Add images to the ProductSerializer
** serializer.py
"
class ProductImageSerializer(serializers.ModelSerializer):
    def create(self, validated_data):
        product_id = self.context['product_id']
        return ProductImage.objects.create(product_id=product_id, **validated_data)
    class Meta:
        model = ProductImage
        fields = ['id', 'image']

class ProductSerializer(serializers.ModelSerializer):
    images = ProductImageSerializer(many=True, read_only=True)
    class Meta:
        model = Product
        fields = ['id', 'title', 'description', 'slug', 'inventory',
                  'unit_price', 'price_with_tax', 'collection', 'images']

    price_with_tax = serializers.SerializerMethodField(
        method_name='calculate_tax')

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
" 
3. Now we can get these images but there are lots of duplicate sql queries, so we need to get the related fields beforehand.
** select_related is best used for "one-to-one" or "many-to-one" relationships.
** prefetch_related, on the other hand, is designed for "one-to-many" and "many-to-many" relationships.

Since we have one to many relationships, we will use prefetch_related.
** views.py
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.prefetch_related('images').all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    permission_classes = [IsAdminOrReadOnly]
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)

        return super().destroy(request, *args, **kwargs)
"

#! JWT Tokens for Authentication
{
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcyMDA4NjgxNCwiaWF0IjoxNzIwMDAwNDE0LCJqdGkiOiI2MjFlYmJjMDJiMTU0NDc2YjMyZDlmYTNmZDQ2ODllOCIsInVzZXJfaWQiOjF9.X7QcxJcHdE_ZGW_AtES_YTAjEHK9otUfEnrmR9tuCMI",
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzIwMDg2ODE0LCJpYXQiOjE3MjAwMDA0MTQsImp0aSI6IjI5ZDIyMDk5MDg3NjRhNmY5NGVlZjZiYTBmOWYyYWMzIiwidXNlcl9pZCI6MX0.dppHRTj3zuhgW0HoETEkiCBKY1ojq-hSA8RBn1TiHLw"
}

Then add "JWT <access_token>" in your ModHeader Chrome extension. Now you can access all the protected routes.

#! Validating uploaded files
1. Create a file called "validators.py" in the "store" app
** validators.py
"
from django.core.exceptions import ValidationError

def validate_file_size(file):
    max_size_kb = 50
    
    if file.size > max_size_kb * 1024:
        raise ValidationError(f'File size should not exceed {max_size_kb} KB')
"

Now add this validator in the ProductImage model
** models.py
"
class ProductImage(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(upload_to='store/images', blank=True, null=True, validators=[validate_file_size])
"

#! Setting Up the Client App
I have uploaded the storefront3_client folder in the root directory of the project.
* Check your node version with "node -v"
* Install the dependencies with "npm install"
* Start the development server with "npm start"

#! Enabling CORS 
1. When we try to upload image from the frontend, we get error: "Could not reach the server!"
2. This is a classic CORS (Cross-Origin Resource Sharing) error.
3. This policy prevents any app hosted in domain1 to send request to apps hosted in domain2.
4. Here we are facing this issue because the client app is hosted in domain1 (8001) and the server is hosted in domain2 (8000).

5. To solve this CORS problem, we need to change some settings from the server side to allow requests from domain1 (8001).
6. We will use django python package "django-cors-headers"
Step-1: "pip install django-cors-headers"
Step-2: Add it to INSTALLED_APPS in settings.py "corsheaders"
Step-3: Add it to MIDDLEWARE in settings.py "corsheaders.middleware.CorsMiddleware"
Step-4: Add it to settings.py "CORS_ALLOWED_ORIGINS"
"
CORS_ALLOWED_ORIGINS = [
    'http://localhost:8001',
    'http://127.0.0.1:8001',
]
"

#! Managing Images in the Admin 
** media/store/styles.css 
"
.thumbnail {
    width: 100px;
    height: 100px;
    object-fit: cover;
}
"

** store/admin.py
"
class ProductImageInline(admin.TabularInline):
    model = models.ProductImage
    readonly_fields = ['thumbnail']

    def thumbnail(self, instance):
        if instance.image.name != '':
            return format_html(f'<img src="{instance.image.url}" class="thumbnail" />')
        return ''
"

** core/admin.py
"
class CustomProductAdmin(ProductAdmin):
    inlines = [TagInline, ProductImageInline]
"

#* Section - 2 (Sending Email)

#! Setting Up a fake SMTP server
1. SMTP -> Simple Mail Transfer Protocol
2. For setting up a fake SMTP server, we will use "https://github.com/rnwood/smtp4dev"
3. Check its installation page, and then we will clone the fake server using docker image 
4. run "docker run --rm -it -p 5000:80 -p 2525:25 rnwood/smtp4dev"
We will get this output:
"
PS C:\Users\CZ0258> docker run --rm -it -p 5000:80 -p 2525:25 rnwood/smtp4dev
Unable to find image 'rnwood/smtp4dev:latest' locally
latest: Pulling from rnwood/smtp4dev
09f376ebb190: Pull complete
7248743022af: Pull complete
95fcf2c5436c: Pull complete
0fbaf16568f1: Pull complete
e9e190cbc518: Pull complete
a893f927642d: Pull complete
25f219cce78d: Pull complete
Digest: sha256:912304153668068188d83b612fe0b7c4ec852dddb45fb2946895c7a72e89c6f2
Status: Downloaded newer image for rnwood/smtp4dev:latest
smtp4dev version 3.6.1+5e577a8b4152ceb7276a5b8d4432430c9ff9055d
https://github.com/rnwood/smtp4dev
.NET Core runtime version: .NET 8.0.4

 > For help use argument --help

Install location: /
DataDir: /smtp4dev
Default settings file: /app/appsettings.json
User settings file: /smtp4dev/appsettings.json
Storing keys in a directory '/root/.aspnet/DataProtection-Keys' that may not be persisted outside of the container. Protected data will be unavailable when container is destroyed. For more information go to https://aka.ms/aspnet/dataprotectionwarning
Parsing AutomaticRelayExpression
Parsing CredentialsValidationExpression
Parsing RecipientValidationExpression
Parsing MessageValidationExpression
No XML encryptor configured. Key {2276da35-cd42-4491-96d2-c05821926287} may be persisted to storage in unencrypted form.
Using Sqlite database at /smtp4dev/database.db
Updating DB schema with migrations: 20181020095712_InitialCreate, 20181021072518_AddSessionToMessageReln, 20181021105259_AddSessionStartData, 20181022132948_AddSessionErrorInfo, 20181022163054_AddAttachmentCount, 20190310130227_AddMessageUnreadFlag, 20200904135503_AddRelayError, 20200924120747_AddImapState, 20210211134331_AddMessageSecurity, 20210731045851_UTCTimeMigration, 20210807032903_MessageRelay, 20210901140449_Fix_Messages_PK, 20240308081358_AddSessionEncoding, 20240309084542_AddMessageEightBitTransport, 20240425190525_AddMailboxes, 20240511110456_AddDeliveredTo, 20240515191815_FixSessionMessageCascasing
Creating mailbox Default
TLS mode: None
SMTP Server is listening on port 25 (::).
Keeping last 100 messages per mailbox and 100 sessions.
IMAP Server is listening on port 143 (::)
Overriding HTTP_PORTS '80' and HTTPS_PORTS ''. Binding to values defined by URLS instead 'http://*:80'.
Now listening on: http://[::]:80
"
5. Now since the server is running on port 5000, we will use "http://localhost:5000" to send an email.

#! Configuring the email backend
There are various types of backends:
* SMTP (default)
* Console
* File
* Locmmem
* Dummy

1. Add the following code in settings.py
"
# EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
# EMAIL_BACKEND = 'django.core.mail.filebased.console.EmailBackend'
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'localhost'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 2525 # Check your email server terminal input command and output from NOTES_3.txt
DEFAULT_FROM_EMAIL = 'from@example.com'
"