#! SECTION - 1
A) Introduction to Django
B) Fundamentals of webdev
C) Setting up development environment
D) First Django Project
E) 2 essential debugging techniques

#? A. Introduction to Django
1. It is a batteries included framework which comes with functionalities liek admin site, object-relation mapping (ORM), template system, authentication system, caching, and many more.

#? B. Fundamentals of webdev
1. Frontend is the client responsible for the user interface and data visualization of the website. Backend is the server responsible for the database, security, caching, and user authentication. 
2. The website has a URL i.e Uniform Resource Locator.  
3. When the url is typed in the browser, it is called as a request. That request is sent to the server. It uses the http protocol.
4. The response of the server is called as a response.
5. The response is sent back to the browser. The response can be in form of HTML, JSON, XML, etc.
6. We have front-end client side frameworks like Angular, React, Vue, etc. and backend server side frameworks like Django, Flask, etc.
7. We send the data in the form of API i.e Application Programming Interface.

#? C. Setting up development environment
1. Create a virtual environment using the command: python -m venv venv
2. Activate the virtual environment using: source venv/bin/activate
3. Install Django using: pip install django
4. Store requirements in requirements.txt using the command: pip freeze > requirements.txt
5. Type "django-admin" to know all the commands we can use in django.
6. Type "django-admin startproject storefront . " to create a project named storefront.
7. Type "python manage.py startapp playground" to create a new app named playground.

#? D. First Django Project and App
1. Create a view named say_hello in views.py
2. Create a urls.py file in apps directory and add the url configuration to urls.py of project's directory.
3. Create a template in templates directory which should be located in the apps directory.

#? E. 2 essential debugging techniques
# TODO Attempt to debug Django applications in VS code
1. Debugging Django Applications in VS code
2. Click the "Debug" button in the VS code. 
3. Now click on the "create a launch.json" file.
4. Select python debugger and then django debugger. 
5. Add this code
"
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python Debugger: Django",
            "type": "debugpy",
            "request": "launch",
            "args": [
                "runserver",
                "9000"
            ],
            "django": true,
            "autoStartBrowser": false,
            "program": "${workspaceFolder}\\Ultimate Django Series 1\\manage.py"
        }
    ]
}
"
6. Now set a breakpoint in the view code.
7. Use F10 to step over to the next line of code. You can see all the debugger options on the top of the code screen.
8. Keep a track of the locals and globals in the debugger.
#! IMPORTANT
9. Add the variable you want to keep track on in the "WATCH" tab of the debugger. Just click the "+" button in the "WATCH" tab.
10. Use the "STEP INTO" button i.e the F11 button to step into the function code.
11. Use the "STEP OUT" button i.e the F12 button to step out of the function code.

#! IMPORTANT
12. You can run your django app without typing python manage.py runserver by using "Ctrl + F5". This will run the django app in the background without the debugger.

# TODO -> Use django-debug-toolbar to debug Django applications
13. Install django-debug-toolbar using: pip install django-debug-toolbar
14. Add it to INSTALLED_APPS in settings.py
15. Add it to MIDDLEWARE in settings.py
16. Add the urls.py to project's urls.py
17. Add INTERNAL_IPS in settings.py
18. You may also add DEBUG_TOOLBAR_PANELS in settings.py
19. Your template code should have html tag with body. Them only the django-debug-toolbar will be visible.
19. Refer "https://django-debug-toolbar.readthedocs.io/en/latest/installation.html" and "https://django-debug-toolbar.readthedocs.io/en/latest/configuration.html"



#! SECTION - 2
Refer => "https://docs.djangoproject.com/en/5.0/ref/models/fields/"
A) Data Models
B) Build e-commerce data Models
C) Organizing models in apps
D) Coding Model classes
"
Creating Models 
Choice Fields
Defining One-to-one and Many-to-one Relationships 
Resolving Circular Relationships
Generic Relationships
"

1. We will have a "STORE" which will have models like "Product", "Collection", "Cart", "CartItem", "Order", "OrderItem", "Customer". This is MONOLITHIC i.e all the fields in one single model. This gets complex as we add more features.
2. To solve this, we will break it to various small apps like "PRODUCTS", "COLLECTIONS", "CARTS", "ORDERS", "CUSTOMERS". This is ORGANIZING MODELS in apps.
#! PRODUCTS
a) Product
b) Collection
c) Tag 
#! CUSTOMERS
a) Customer
#! CARTS
a) Cart
b) CartItem
#! ORDERS
a) Order
b) OrderItem
3. But this approach too is not scalable as each model will be dependent on other models. So we will use "Django ORM".
4. We will have 2 apps, "store" and "tags".
5. Type "python manage.py startapp store" and "python manage.py startapp tags" in the terminal.
6. Add these apps in the INSTALLED_APPS in settings.py

#! CHOICE FIELDS - If a mapping is given, the key element is the actual value to be set on the model, and the second element is the human readable name.
#? Method - 1
"
class Customer(models.Model):
    MEMBERSHIP_CHOICES = [
        ("B", "Bronze"),
        ("S", "Silver"),
        ("G", "Gold"),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True)
    membership = models.CharField(
        max_length=1,
        choices=MEMBERSHIP_CHOICES,
        default="B",
    )
"
#? Method - 2  MORE ELEGANT
"
class Customer(models.Model):
    MEMBERSHIP_BRONZE = "B"
    MEMBERSHIP_SILVER = "S"
    MEMBERSHIP_GOLD = "G"

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, "Bronze"),
        (MEMBERSHIP_SILVER, "Silver"),
        (MEMBERSHIP_GOLD, "Gold"),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True)
    membership = models.CharField(
        max_length=1,
        choices=MEMBERSHIP_CHOICES,
        default=MEMBERSHIP_BRONZE,
    )
"

#! README: The primary difference between using a OneToOneField and a ForeignKey in Django models is the nature of the relationship they define between the two models.
OneToOneField
A OneToOneField creates a one-to-one relationship between two models. This means that each instance of the referenced model can be related to exactly one instance of the model that contains the OneToOneField, and vice versa. It is a special case of a foreign key with unique constraints.

ForeignKey
A ForeignKey creates a one-to-many relationship between two models. This means that each instance of the referenced model can be related to multiple instances of the model that contains the ForeignKey.

#! Defining One-to-one Relationships 
# Here, the Customer is the parent class and the Address is the child class.
# Here we want that each customer has only one address.
"
class Address(models.Model):
    street = models.CharField(max_length=255)
    city = models.CharField(max_length=255)
    customer = models.OneToOneField(Customer, on_delete=models.CASCADE, primary_key=True)
"

#! Defining One-to-many Relationships
"
class Address(models.Model):
    street = models.CharField(max_length=255)
    city = models.CharField(max_length=255)
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE)
"

#! Defining Many-to-many Relationships
"
class Promotion(models.Model):
    description = models.CharField(max_length=255)
    discount = models.FloatField()
    # product_set is be named as products when related_name is set to 'products

    
class Product(models.Model):
    title = models.CharField(max_length=255)
    description = models.TextField()
    price = models.DecimalField(max_digits=6, decimal_places=2)
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)
    promotions = models.ManyToManyField(Promotion)
    # promotions = models.ManyToManyField(Promotion, related_name='products')
"