This this the second part of the series which will be continued from where the first part ended.

#! Set up the database and code for the project
1. Open MySQL Workbench and create a new database named storefront2.
2. Run "python manage.py makemigrations" and "python manage.py migrate" to create the tables in the database.
3. Now go to Server option and click in Data Import, then select the seed2 and storefront2 database. Click start import.
4. Create superuser for the admin panel.

#! What are RESTful APIs 
* API stands for Application Programming Interface.
* API is a set of instructions that a server uses to understand and respond to a request. * It is dynamic in nature and can be used to interact with any web service.
* Different endpoints in an API results in different actions.
* It is a standard that defines how a server should respond to a request.

* RESTful API means Representational State Transfer (REST).
* RESTful APIs has many benifits like they are fast, secure, scalability, maintainability, easy to understand and easy to change.

** Main 3 things in RESTful API are --> resources, representations and HTTP methods.

#! Resources
A resource in an API is just like a application in our project like "Products", "Collections", "Tags", "Carts", "Orders", "Customers".
* Resources are just collection of data.
* Resources are identified by their URLs (Uniform Resource Locator).

#! Resource Representations
* A resource representation is a representation of a resource in a particular format.
* A resource representation is identified by its pattern.

#! HTTP Methods
* HTTP methods are a set of verbs that a server can use to perform various actions on a resource.
* HTTP methods are identified by their name.
* HTTP methods --> GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD

#! Install Django REST framework
1. pip install djangorestframework
2. Add 'rest_framework' to INSTALLED_APPS in settings.py

#! Creating API views
1. In views.py from store app, create a view named product_list and link it with a url "products/" in urls.py
"
from django.shortcuts import render
from django.http import HttpResponse

def product_list(request):
    return HttpResponse("You're at the store product list.")
"
2. Add "path('store/', include('store.urls'))," to urls.py of the project directory.

Django has "HttpRequest" and "HttpResponse" classes.
REST Framework has "Request" and "Response" classes, which are much simpler but more powerful. 

3. Use "from rest_framework.decorators import api_view" to overwrite the default Django request with REST framework request.
4. Use "from rest_framework.response import Response" to overwrite the default Django response with REST framework response.
5. Now we get a browsable API at "http://127.0.0.1:8000/store/products/"

** views.py
"
from django.shortcuts import render
from django.http import HttpResponse
from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view()
def product_list(request):
    return Response("You're at the store product list.")

@api_view()
def product_detail(request, id):
    return Response(id)
"

** urls.py
"
from django.urls import path
from . import views

urlpatterns = [
    path('products/', views.product_list),
    path('products/<int:id>/', views.product_detail),
]
"

#! Creating Serializers
"
from rest_framework import serializers

class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)
"

* Add the following code in the project settings.py to change the default behaviour of the serializer to change integer to string
"
REST_FRAMEWORK = {
    'COERCE_DECIMAL_TO_STRING': False
}
"

** views.py
"
@api_view()
def product_detail(request, id):
    try:
        product = Product.objects.get(pk=id)
        serializer = ProductSerializer(product)
        return Response(serializer.data)
    except Product.DoesNotExist:
        return Response(status=status.HTTP_404_NOT_FOUND)
"
Alternatively, use "from django.shortcuts import get_object_or_404"
"
@api_view()
def product_detail(request, id):
    product = get_object_or_404(Product, pk=id)
    serializer = ProductSerializer(product)
    return Response(serializer.data)
"

* Add many=True in ProductSerializer to get all the products
"
@api_view()
def product_list(request):
    queryset = Product.objects.all()
    serializer = ProductSerializer(queryset, many=True)
    return Response(serializer.data)
"

#! Creating Custom Serializer Fields 
** serializers.py
"
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price')
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"
* Here we have renamed the unit_price field to price.
* We also added a new custom field "price_with_tax" which is calculated using calculate_tax method.

#! Serializing Relationships 
There are 4 ways to serialize the relationship between 2 models:-
#? Primary Key
#? String
#? Nested object
#? Hyperlink

Here we are serializing the relationship between Product and Collection.
1. Method - 1: To get the relationship between Product and Collection, we use "PrimaryKeyRelatedField" in ProductSerializer.
"
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price')
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    collection = serializers.PrimaryKeyRelatedField(
        queryset=Collection.objects.all()
    )

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"

2. Method - 2: Here we are serializing the relationship between Product and Collection using "StringRelatedField" in ProductSerializer, this will return the title of the collection.

* Add "queryset = Product.objects.select_related('collection').all()" in the view to get the collection title of the product faster else for 1000 records it will execute 1000 queries to the database.
"
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price')
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    collection = serializers.StringRelatedField()

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"
3. Method - 3: Here we using nested serializer concept
"
class CollectionSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)


class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(
        max_digits=6, decimal_places=2, source="unit_price"
    )
    price_with_tax = serializers.SerializerMethodField(method_name="calculate_tax")
    collection = CollectionSerializer()

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"

4. Method - 4: Here we use HyperlinkedRelatedField to get the relationship between Product and Collection
** serializers.py
"
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(
        max_digits=6, decimal_places=2, source="unit_price"
    )
    price_with_tax = serializers.SerializerMethodField(method_name="calculate_tax")
    collection = serializers.HyperlinkedRelatedField(
        queryset=Collection.objects.all(),
        view_name="collection-detail",
    )

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"
** views.py
"
@api_view()
def collection_detail(request, pk):
    return Response(f"Collection {pk}")
"
** urls.py
"
urlpatterns = [
    path('products/', views.product_list),
    path('products/<int:id>/', views.product_detail),
    path('collections/<int:pk>/', views.collection_detail, name='collection-detail'),
]
"

#! Model Serializers
"
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ["id", "title", "unit_price", "price_with_tax", "collection"]
        # fields = ['id', 'title', 'price', 'collection']

    # price = serializers.DecimalField(max_digits=6, decimal_places=2, source="unit_price")
    price_with_tax = serializers.SerializerMethodField(method_name="calculate_tax")

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"