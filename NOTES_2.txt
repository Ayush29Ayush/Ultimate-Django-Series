This this the second part of the series which will be continued from where the first part ended.

#* Section - 1 (Setting Up the Project and Database)

#! Set up the database and code for the project
1. Open MySQL Workbench and create a new database named storefront2.
2. Run "python manage.py makemigrations" and "python manage.py migrate" to create the tables in the database.
3. Now go to Server option and click in Data Import, then select the seed2 and storefront2 database. Click start import.
4. Create superuser for the admin panel.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#* Section - 2 (RESTful APIs)

#! What are RESTful APIs 
* API stands for Application Programming Interface.
* API is a set of instructions that a server uses to understand and respond to a request. * It is dynamic in nature and can be used to interact with any web service.
* Different endpoints in an API results in different actions.
* It is a standard that defines how a server should respond to a request.

* RESTful API means Representational State Transfer (REST).
* RESTful APIs has many benifits like they are fast, secure, scalability, maintainability, easy to understand and easy to change.

** Main 3 things in RESTful API are --> resources, representations and HTTP methods.

#! Resources
A resource in an API is just like a application in our project like "Products", "Collections", "Tags", "Carts", "Orders", "Customers".
* Resources are just collection of data.
* Resources are identified by their URLs (Uniform Resource Locator).

#! Resource Representations
* A resource representation is a representation of a resource in a particular format.
* A resource representation is identified by its pattern.

#! HTTP Methods
* HTTP methods are a set of verbs that a server can use to perform various actions on a resource.
* HTTP methods are identified by their name.
* HTTP methods --> GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD

#! Install Django REST framework
1. pip install djangorestframework
2. Add 'rest_framework' to INSTALLED_APPS in settings.py

#! Creating API views
1. In views.py from store app, create a view named product_list and link it with a url "products/" in urls.py
"
from django.shortcuts import render
from django.http import HttpResponse

def product_list(request):
    return HttpResponse("You're at the store product list.")
"
2. Add "path('store/', include('store.urls'))," to urls.py of the project directory.

Django has "HttpRequest" and "HttpResponse" classes.
REST Framework has "Request" and "Response" classes, which are much simpler but more powerful. 

3. Use "from rest_framework.decorators import api_view" to overwrite the default Django request with REST framework request.
4. Use "from rest_framework.response import Response" to overwrite the default Django response with REST framework response.
5. Now we get a browsable API at "http://127.0.0.1:8000/store/products/"

** views.py
"
from django.shortcuts import render
from django.http import HttpResponse
from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view()
def product_list(request):
    return Response("You're at the store product list.")

@api_view()
def product_detail(request, id):
    return Response(id)
"

** urls.py
"
from django.urls import path
from . import views

urlpatterns = [
    path('products/', views.product_list),
    path('products/<int:id>/', views.product_detail),
]
"

#! Creating Serializers
"
from rest_framework import serializers

class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)
"

* Add the following code in the project settings.py to change the default behaviour of the serializer to change integer to string
"
REST_FRAMEWORK = {
    'COERCE_DECIMAL_TO_STRING': False
}
"

** views.py
"
@api_view()
def product_detail(request, id):
    try:
        product = Product.objects.get(pk=id)
        serializer = ProductSerializer(product)
        return Response(serializer.data)
    except Product.DoesNotExist:
        return Response(status=status.HTTP_404_NOT_FOUND)
"
Alternatively, use "from django.shortcuts import get_object_or_404"
"
@api_view()
def product_detail(request, id):
    product = get_object_or_404(Product, pk=id)
    serializer = ProductSerializer(product)
    return Response(serializer.data)
"

* Add many=True in ProductSerializer to get all the products
"
@api_view()
def product_list(request):
    queryset = Product.objects.all()
    serializer = ProductSerializer(queryset, many=True)
    return Response(serializer.data)
"

#! Creating Custom Serializer Fields 
** serializers.py
"
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price')
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"
* Here we have renamed the unit_price field to price.
* We also added a new custom field "price_with_tax" which is calculated using calculate_tax method.

#! Serializing Relationships 
There are 4 ways to serialize the relationship between 2 models:-
#? Primary Key
#? String
#? Nested object
#? Hyperlink

Here we are serializing the relationship between Product and Collection.
1. Method - 1: To get the relationship between Product and Collection, we use "PrimaryKeyRelatedField" in ProductSerializer.
"
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price')
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    collection = serializers.PrimaryKeyRelatedField(
        queryset=Collection.objects.all()
    )

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"

2. Method - 2: Here we are serializing the relationship between Product and Collection using "StringRelatedField" in ProductSerializer, this will return the title of the collection.

* Add "queryset = Product.objects.select_related('collection').all()" in the view to get the collection title of the product faster else for 1000 records it will execute 1000 queries to the database.
"
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price')
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    collection = serializers.StringRelatedField()

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"
3. Method - 3: Here we using nested serializer concept
"
class CollectionSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)


class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(
        max_digits=6, decimal_places=2, source="unit_price"
    )
    price_with_tax = serializers.SerializerMethodField(method_name="calculate_tax")
    collection = CollectionSerializer()

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"

4. Method - 4: Here we use HyperlinkedRelatedField to get the relationship between Product and Collection
** serializers.py
"
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(
        max_digits=6, decimal_places=2, source="unit_price"
    )
    price_with_tax = serializers.SerializerMethodField(method_name="calculate_tax")
    collection = serializers.HyperlinkedRelatedField(
        queryset=Collection.objects.all(),
        view_name="collection-detail",
    )

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"
** views.py
"
@api_view()
def collection_detail(request, pk):
    return Response(f"Collection {pk}")
"
** urls.py
"
urlpatterns = [
    path('products/', views.product_list),
    path('products/<int:id>/', views.product_detail),
    path('collections/<int:pk>/', views.collection_detail, name='collection-detail'),
]
"

#! Model Serializers
"
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ["id", "title", "unit_price", "price_with_tax", "collection"]
        # fields = ['id', 'title', 'price', 'collection']

    # price = serializers.DecimalField(max_digits=6, decimal_places=2, source="unit_price")
    price_with_tax = serializers.SerializerMethodField(method_name="calculate_tax")

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"

#! Deserializing Objects and Data Validation
1. Deserialization is the process of converting a JSON object into a Python object.
2. It is the opposite of serializing.
3. It happens when the server gets data from a client.

4. Method - 1
"
@api_view(["GET", "POST"])
def product_list(request):
    if request.method == "GET":
        queryset = Product.objects.select_related("collection").all()
        serializer = ProductSerializer(
            queryset, many=True, context={"request": request}
        )
        return Response(serializer.data)
    elif request.method == "POST":
        serializer = ProductSerializer(data=request.data)
        if serializer.is_valid():
            print(serializer.validated_data)
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        else:
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
"
5. Method - 2 : rather than using this if else block for validating data, we can use "is_valid(raise_exception=True)"
"
@api_view(["GET", "POST"])
def product_list(request):
    if request.method == "GET":
        queryset = Product.objects.select_related("collection").all()
        serializer = ProductSerializer(
            queryset, many=True, context={"request": request}
        )
        return Response(serializer.data)
    elif request.method == "POST":
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        print(serializer.validated_data)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)
"

#! Saving Objects
Data to create using POST
"
{
   "title": "a",
   "slug": "a",
   "unit_price": 1,
   "collection": 1,
   "inventory": 1
}
"
** serializers.py
"
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ["id", "title", "description", "slug", "inventory", "unit_price", "price_with_tax", "collection"]

    price_with_tax = serializers.SerializerMethodField(method_name="calculate_tax")

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"

** views.py
"
@api_view(["GET", "POST"])
def product_list(request):
    if request.method == "GET":
        queryset = Product.objects.select_related("collection").all()
        serializer = ProductSerializer(
            queryset, many=True, context={"request": request}
        )
        return Response(serializer.data)
    elif request.method == "POST":
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        print(serializer.validated_data)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)


@api_view(["GET", "PUT"])
def product_detail(request, id):
    if request.method == "GET":
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product)
        return Response(serializer.data)
    elif request.method == "PUT":
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)
"

#! Deleting Objects
** models.py
"class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.PROTECT)
    product = models.ForeignKey(Product, on_delete=models.PROTECT, related_name='orderitems')
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6, decimal_places=2)
"
** views.py
"
@api_view(["GET", "PUT", "DELETE"])
def product_detail(request, id):
    if request.method == "GET":
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product)
        return Response(serializer.data)
    elif request.method == "PUT":
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)
    elif request.method == "DELETE":
        product = get_object_or_404(Product, pk=id)
        
        if product.orderitems.count() > 0:
            return Response({"error": "Product cannot be deleted because it is associated with an order item."}, status=status.HTTP_405_METHOD_NOT_ALLOWED)

        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
"

#! Exercise- Building the Collections API
Ques) Implement the Collection API similar to the Product API
Ans)

** models.py -> we added a related_name="products" in the Product model to get the products in the collection using COUNT.
"
class Product(models.Model):
    title = models.CharField(max_length=255)
    slug = models.SlugField()
    description = models.TextField(null=True, blank=True)
    unit_price = models.DecimalField(
        max_digits=6,
        decimal_places=2,
        validators=[MinValueValidator(1)])
    inventory = models.IntegerField(validators=[MinValueValidator(0)])
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT, related_name='products')
    promotions = models.ManyToManyField(Promotion, blank=True)

    def __str__(self) -> str:
        return self.title

    class Meta:
        ordering = ['title']
"
** views.py
"
@api_view(["GET", "POST"])
def collection_list(request):
    if request.method == "GET":
        queryset = Collection.objects.annotate(products_count=Count("products")).all()
        serializer = CollectionSerializer(queryset, many=True)
        return Response(serializer.data)
    elif request.method == "POST":
        serializer = CollectionSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)


@api_view(["GET", "PUT", "DELETE"])
def collection_detail(request, pk):
    # collection = get_object_or_404(Collection, pk=pk) // gives error because products_count is not defined by default but is required in CollectionSerializer
    collection = get_object_or_404(
        Collection.objects.annotate(products_count=Count("products")).all(), pk=pk
    )
    if request.method == "GET":
        serializer = CollectionSerializer(collection)
        return Response(serializer.data)
    elif request.method == "PUT":
        serializer = CollectionSerializer(collection, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)
    elif request.method == "DELETE":
        if collection.products.count() > 0:
            return Response(
                {
                    "error": "Collection cannot be deleted because it includes one or more products."
                },
                status=status.HTTP_405_METHOD_NOT_ALLOWED,
            )
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
"
** serializers.py
"
class CollectionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Collection
        fields = ["id", "title", "products_count"]
        
    products_count = serializers.IntegerField(read_only=True)
"
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#* Section - 3 (Advanced API concepts)
* Class-based views
* Generic views
* Viewsets
* Routers
* Searching, filtering, pagination, etc.

#! Class-based views
1. All the API views we created till now were functional based views but django also supports class-based views which promote reusability and modularity. They are prefered over functional based views.
2. The class-based views have a particular naming convention i.e Capital letters and without any underscores.
3. The functional-based views have a particular naming convention i.e lowercase letters and with underscores.

** views.py
"
class ProductList(APIView):
    def get(self, request):
        queryset = Product.objects.select_related("collection").all()
        serializer = ProductSerializer(
            queryset, many=True, context={"request": request}
        )
        return Response(serializer.data)

    def post(self, request):
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        print(serializer.validated_data)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)


class ProductDetail(APIView):
    def get(self, request, id):
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product)
        return Response(serializer.data)

    def put(self, request, id):
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)

    def delete(self, request, id):
        product = get_object_or_404(Product, pk=id)
        if product.orderitems.count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                },
                status=status.HTTP_405_METHOD_NOT_ALLOWED,
            )
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)


class CollectionList(APIView):
    def get(self, request):
        queryset = Collection.objects.annotate(products_count=Count("products")).all()
        serializer = CollectionSerializer(queryset, many=True)
        return Response(serializer.data)

    def post(self, request):
        serializer = CollectionSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)


class CollectionDetail(APIView):
    def get(self, request, pk):
        collection = get_object_or_404(
            Collection.objects.annotate(products_count=Count("products")).all(), pk=pk
        )
        serializer = CollectionSerializer(collection)
        return Response(serializer.data)

    def put(self, request, pk):
        collection = get_object_or_404(
            Collection.objects.annotate(products_count=Count("products")).all(), pk=pk
        )
        serializer = CollectionSerializer(collection, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)

    def delete(self, request, pk):
        collection = get_object_or_404(
            Collection.objects.annotate(products_count=Count("products")).all(), pk=pk
        )
        if collection.products_count > 0:
            return Response(
                {
                    "error": "Collection cannot be deleted because it includes one or more products."
                },
                status=status.HTTP_405_METHOD_NOT_ALLOWED,
            )
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
"
** urls.py
"
urlpatterns = [
    path('products/', views.ProductList.as_view()),
    path('products/<int:id>/', views.ProductDetail.as_view()),
    path('collections/<int:pk>/', views.CollectionDetail.as_view(), name='collection-detail'),
    path('collections/', views.CollectionList.as_view()),
]
"

#! Mixins 
Link -> "https://www.django-rest-framework.org/api-guide/generic-views/"
* Pretty much similar to our implementation in views till now.

#! Generic Views 
Most Common Generic Views are "ListCreateAPIView" and "RetrieveUpdateDestroyAPIView"

* Rather than using mixins directly, we use concrete classes like "Generic Views".
* Generic views are used to implement common operations like searching, filtering, ordering, pagination, etc.
Here we re-write the ProductList and CollectionList views using generic views -> "ListCreateAPIView"
"
class ProductList(ListCreateAPIView):
    queryset = Product.objects.select_related("collection").all()
    serializer_class = ProductSerializer

    def get_serializer_context(self):
        return {"request": self.request}

class CollectionList(ListCreateAPIView):
    queryset = Collection.objects.annotate(products_count=Count("products")).all()
    serializer_class = CollectionSerializer
    
    def get_serializer_context(self):
        return {"request": self.request}
"

#! Customizing Generic Views
Here we are using "RetrieveUpdateDestroyAPIView" which is a class that extends the generic views. It allows us to get, update and delete objects. Since we have a custom logic for delete, we overwrite the "delete" method.
Since these generic views use "pk" instead of "id", we have used "pk" through out the code.
** views.py
"
class ProductDetail(RetrieveUpdateDestroyAPIView):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    
    # def get(self, request, id):
    #     product = get_object_or_404(Product, pk=id)
    #     serializer = ProductSerializer(product)
    #     return Response(serializer.data)

    # def put(self, request, id):
    #     product = get_object_or_404(Product, pk=id)
    #     serializer = ProductSerializer(product, data=request.data)
    #     serializer.is_valid(raise_exception=True)
    #     serializer.save()
    #     return Response(serializer.data)

    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                },
                status=status.HTTP_405_METHOD_NOT_ALLOWED,
            )
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

class CollectionDetail(RetrieveUpdateDestroyAPIView):
    queryset = Collection.objects.annotate(products_count=Count("products")).all()
    serializer_class = CollectionSerializer

    def delete(self, request, pk):
        collection = get_object_or_404(
            Collection.objects.annotate(products_count=Count("products")).all(), pk=pk
        )
        if collection.products_count > 0:
            return Response(
                {
                    "error": "Collection cannot be deleted because it includes one or more products."
                },
                status=status.HTTP_405_METHOD_NOT_ALLOWED,
            )
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
"

** urls.py
"
urlpatterns = [
    path('products/', views.ProductList.as_view()),
    path('products/<int:pk>/', views.ProductDetail.as_view()),
    path('collections/<int:pk>/', views.CollectionDetail.as_view(), name='collection-detail'),
    path('collections/', views.CollectionList.as_view()),
]
"

#! ViewSets
Most common ViewSets are "ModelViewSet" and "GenericViewSet"
* Naming convention is similar to generic views -> "ModelViewSet" will be "ProductViewSet"
* It is just a class which has all the features of generic views and mixins.
* Now rather than using 2 classes "ProductList" and "ProductDetail" in views.py, we can use "ProductViewSet" in views.py

** views.py
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                },
                status=status.HTTP_405_METHOD_NOT_ALLOWED,
            )
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)


class CollectionViewSet(ModelViewSet):
    queryset = Collection.objects.annotate(products_count=Count("products")).all()
    serializer_class = CollectionSerializer
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def delete(self, request, pk):
        collection = get_object_or_404(
            Collection.objects.annotate(products_count=Count("products")).all(), pk=pk
        )
        if collection.products_count > 0:
            return Response(
                {
                    "error": "Collection cannot be deleted because it includes one or more products."
                },
                status=status.HTTP_405_METHOD_NOT_ALLOWED,
            )
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
"

#! Routers
There are 2 types of routers -> "DefaultRouter" and "SimpleRouter"
* DefaultRouter gives us the ability to use "ModelViewSet" and "GenericViewSet" in views.py
* SimpleRouter gives us all the routes for that project in urls.py

Using DefaultRouter, we get:
"
HTTP 200 OK
Allow: GET, HEAD, OPTIONS
Content-Type: application/json
Vary: Accept

{
    "products": "http://127.0.0.1:8000/store/products/",
    "collections": "http://127.0.0.1:8000/store/collections/"
}
"
"

Using SimpleRouter, we get these from router.urls:
"
[<URLPattern '^products/$' [name='product-list']>,
 <URLPattern '^products/(?P<pk>[^/.]+)/$' [name='product-detail']>,
 <URLPattern '^collections/$' [name='collection-list']>,
 <URLPattern '^collections/(?P<pk>[^/.]+)/$' [name='collection-detail']>]
"

** urls.py
"
from django.urls import path
from rest_framework.routers import SimpleRouter, DefaultRouter
from . import views
from pprint import pprint

router = SimpleRouter()

router.register('products', views.ProductViewSet)
router.register('collections', views.CollectionViewSet)

pprint(router.urls)

# URLConf
# urlpatterns = [
    # path('products/', views.ProductList.as_view()),
    # path('products/<int:pk>/', views.ProductDetail.as_view()),
    # path('collections/<int:pk>/', views.CollectionDetail.as_view(), name='collection-detail'),
    # path('collections/', views.CollectionList.as_view()),
# ]

urlpatterns = router.urls
"

Since we are using ModelViewSet, destroy is used instead of delete.
** views.py
"
from django.shortcuts import render, get_object_or_404
from django.http import HttpResponse
from django.db.models import Count
from rest_framework.mixins import ListModelMixin, CreateModelMixin
from rest_framework.generics import ListCreateAPIView, RetrieveUpdateDestroyAPIView
from rest_framework.viewsets import ModelViewSet
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework import status
from store.models import Collection, OrderItem, Product
from store.serializers import CollectionSerializer, ProductSerializer


class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                }
            )
        return super().destroy(request, *args, **kwargs)
    
    # def delete(self, request, pk):
    #     product = get_object_or_404(Product, pk=pk)
    #     if product.orderitems.count() > 0:
    #         return Response(
    #             {
    #                 "error": "Product cannot be deleted because it is associated with an order item."
    #             },
    #             status=status.HTTP_405_METHOD_NOT_ALLOWED,
    #         )
    #     product.delete()
    #     return Response(status=status.HTTP_204_NO_CONTENT)


class CollectionViewSet(ModelViewSet):
    queryset = Collection.objects.annotate(products_count=Count("products")).all()
    serializer_class = CollectionSerializer
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if Product.objects.filter(collection_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Collection cannot be deleted because it includes one or more products."
                }
            )
            
        return super().destroy(request, *args, **kwargs)
    
    # def delete(self, request, pk):
    #     collection = get_object_or_404(
    #         Collection.objects.annotate(products_count=Count("products")).all(), pk=pk
    #     )
    #     if collection.products_count > 0:
    #         return Response(
    #             {
    #                 "error": "Collection cannot be deleted because it includes one or more products."
    #             },
    #             status=status.HTTP_405_METHOD_NOT_ALLOWED,
    #         )
    #     collection.delete()
    #     return Response(status=status.HTTP_204_NO_CONTENT)

"

#! Building the Reviews API 
Step-1
* Create a review model
* Run makemigrations
* Migrate

Step-2
* Create a ReviewSerializer
* Create a view
* Register a route

#! Nested Routers 
For urls like "products/<int:pk>/reviews/", we can use NestedRouters.
Refer => "https://pypi.org/project/drf-nested-routers/" and "https://github.com/alanjds/drf-nested-routers"
* pip install drf-nested-routers

Create a new serializer for reviews:
"
class ReviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = Review
        fields = ["id", "date", "name", "description"]
        # fields = ["id", "date", "name", "description", "product"]
        
    def create(self, validated_data):
        product_id = self.context["product_id"]
        return Review.objects.create(product_id=product_id, **validated_data)
"

Create a new view for reviews:
"
class ReviewViewSet(ModelViewSet):
    # queryset = Review.objects.all()
    serializer_class = ReviewSerializer
    
    #! This is same as defining queryset but since we want the Reviews to be filtered acc to the pk, we will overwrite the default get_queryset()
    def get_queryset(self):
        # print(self.kwargs)
        return Review.objects.filter(product_id=self.kwargs["product_pk"])
    
    #! Since we do not want to pass the product id manually and want it to be taken from the url, pass the url details as context
    def get_serializer_context(self):
        print(self.kwargs)
        return {"product_id": self.kwargs["product_pk"]}
"

Then go to "store/urls.py" and write the following code:
"
from django.urls import path
# from rest_framework.routers import SimpleRouter, DefaultRouter
from rest_framework_nested import routers
from . import views
from pprint import pprint

router = routers.DefaultRouter()

router.register('products', views.ProductViewSet)
router.register('collections', views.CollectionViewSet)

products_router = routers.NestedDefaultRouter(router, 'products', lookup='product')
products_router.register('reviews', views.ReviewViewSet, basename='product-reviews')

urlpatterns = router.urls + products_router.urls

# pprint(router.urls)
pprint(urlpatterns)
"

#! Filtering Data
Since we want the filtering to happen in Product API when any collection_id is passed as a params in the url, we will overwrite the default get_queryset() method in ProductViewSet
"
class ProductViewSet(ModelViewSet):
    # queryset = Product.objects.all()
    serializer_class = ProductSerializer
    
    def get_queryset(self):
        pprint(self)
        queryset = Product.objects.all()
        # collection_id = self.request.query_params['collection_id']
        collection_id = self.request.query_params.get('collection_id')
        
        if collection_id is not None:
            queryset = queryset.filter(collection_id=collection_id)
        
        return queryset
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                }
            )
        return super().destroy(request, *args, **kwargs)
"
#? but after removing the queryset field from the ProductViewSet, we will get an error as shown below:
"
File "D:\Ultimate-Django-Series\venv\Lib\site-packages\rest_framework\routers.py", line 170, in get_default_basename
    assert queryset is not None, '`basename` argument not specified, and could ' \
AssertionError: `basename` argument not specified, and could not automatically determine the name from the viewset, as it does not have a `.queryset` attribute.
"
#? Read this error carefully, to fix it add a basename in the url for products "router.register('products', views.ProductViewSet, basename='products')" and rerun the server.

#! Generic Filtering 
It is getting very complex to apply the filter logic with ModelViewSet, so we can use generic filters like "django_filters"
1. pip install django-filter
2. Using this, we can completely remove the get_queryset() logic, just add filter_backends and filterset_fields.
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['collection_id']
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                }
            )
        return super().destroy(request, *args, **kwargs)
"
3. If we want to filter the products based on a range of unit_price, we can use django_filters but with custom filters.
4. Create a filters.py file in the store folder and write the following code:
** filters.py
"
from django_filters.rest_framework import FilterSet
from store.models import Product

class ProductFilter(FilterSet):
    class Meta:
        model = Product
        fields = {
            'collection_id': ['exact'],
            'unit_price': ['gt', 'lt']
        }
"
** views.py
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_class = ProductFilter
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                }
            )
        return super().destroy(request, *args, **kwargs)
"

#! Searching
* import statement: "from rest_framework.filters import SearchFilter"
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_class = ProductFilter
    # Search_fields = ["title", "description", 'collection__title']
    search_fields = ["title", "description"]
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                }
            )
        return super().destroy(request, *args, **kwargs)
"

#! Sorting
* import statement: "from rest_framework.filters import OrderingFilter"
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    # Search_fields = ["title", "description", 'collection__title']
    search_fields = ["title", "description"]
    ordering_fields = ["unit_price", "last_update"]
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                }
            )
        return super().destroy(request, *args, **kwargs)
"

#! Pagination
* import statement: "from rest_framework.pagination import PageNumberPagination"
** views.py
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    search_fields = ["title", "description"]
    ordering_fields = ["unit_price", "last_update"]
    pagination_class = PageNumberPagination 
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                }
            )
        return super().destroy(request, *args, **kwargs)

"
but if you want more control on the pagination, you can create a pagination.py file and write the following code:
"
from rest_framework.pagination import PageNumberPagination

class DefaultPagination(PageNumberPagination):
    page_size = 10
    page_size_query_param = 'page_size'
    max_page_size = 123
"
then we would not require the import statement: "from rest_framework.pagination import PageNumberPagination"
** views.py
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    search_fields = ["title", "description"]
    ordering_fields = ["unit_price", "last_update"]
    # pagination_class = PageNumberPagination 
    pagination_class = DefaultPagination 
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                }
            )
        return super().destroy(request, *args, **kwargs)
"

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#* Section - 4 (Designing a shopping Cart API)
#! Operations needed to design a shopping cart API:-
* Create a cart
* Add items to a cart
* Update the quantity of items
* Remove items from a cart
* Get a cart with its items
* Delete a cart

#! For each operation, specify the following:-
* Method
* url endpoints
* request body
* response body

a) Creating a cart
* Method -> POST
* url endpoint -> /carts/
* request body -> None
* response body -> Cart object

b) Getting a cart
* Method -> GET
* url endpoint -> /carts/{id}/
* request body -> None
* response body -> Cart object

c) Deleting a cart
* Method -> DELETE
* url endpoint -> /carts/{id}/
* request body -> None
* response body -> None

d) Adding items to a cart
* Method -> POST
* url endpoint -> /carts/{id}/items/
* request body -> Item object -> {"product_id": 1, "quantity": 2}
* response body -> Item object

e) Updating the item
* Method -> PATCH in place of PUT because we want to update the quantity only and not the whole item
* url endpoint -> /carts/{id}/items/{item_id}/
* request body -> Item object -> {"quantity": 3}
* response body -> Item object -> {"product_id": 1, "quantity": 3}

f) Deleting an item
* Method -> DELETE
* url endpoint -> /carts/{id}/items/{item_id}/
* request body -> None
* response body -> None

So in total there will be 2 ViewSets:
a) "CartViewSet" contains "/carts" and "/carts/:id"
b) "CartItemViewSet" contains "/carts/:id/items" and "/carts/:id/items/:item_id"

#! Revisiting the Data Model
"class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)"
1. Our cart model contains pk i.e the "id" and "created_at" but the hacker can easily guess numbers like 1,2,3,etc in urls like "/carts/1/", "/carts/2/", "/carts/3/", etc.
2. To prevent this, we willl use GUID (Globally Unique Identifier) instead of default pk i.e the "id".
3. Now our url will look like "/carts/7b7b5b5b-7b5b-7b5b-7b5b-7b5b7b5b7b5b/"
4. Now our cart model looks like:
"
from uuid import uuid4

class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4)
    created_at = models.DateTimeField(auto_now_add=True)
"
5. Also make changes in CartItem model by adding a related_name and unique_together so that no 2 products can be added to the same cart.
"
class CartItem(models.Model):
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE, related_name='items') # By default, it was 'cartitem_set'
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()
    
    class Meta:
        unique_together = [['cart', 'product']]
"
6. Run commands "python manage.py makemigrations" and "python manage.py migrate" for these changes to be reflected in the database.

#! Creating a Cart 
Step - 1: Create a serializer
Step - 2: Create a viewset
Step - 3: Create a route

#? ModelViewSet: A viewset that provides default create(), retrieve(), update(), partial_update(), destroy() and list() actions.
#! Since we only need operations like "Creating a cart", "Getting a cart", "Deleting a cart" using POST, GET using id and DELETE methods, we will not use ModelViewSet because it will provide us with list and update methods which will expose all our data in the API. To prevent this, we will create a custom ViewSet.
#TODO : Create a custom ViewSet by combining various mixins and generic view set. Click on "ModelViewSet" using "Ctrl+Click" to see its implementation.
** serializers.py
"
class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)
    class Meta:
        model = Cart
        fields = ["id"]
"

** views.py
"
class CartViewSet(CreateModelMixin, GenericViewSet):
    #* CreateModelMixin: Used to create a model instance using POST method.
    queryset = Cart.objects.all()
    serializer_class = CartSerializer
"

** urls.py
"
router.register('carts', views.CartViewSet)
"

#! Getting a cart
We need a GET method to get the cart instance

** serializers.py
"
class SimpleProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ["id", "title", "unit_price"]
    
    
class CartItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer()
    total_price = serializers.SerializerMethodField()
    
    def get_total_price(self, cart_item: CartItem):
        return cart_item.quantity * cart_item.product.unit_price
    class Meta:
        model = CartItem
        fields = ["id", "product", "quantity", "total_price"]
        
        
class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)
    items = CartItemSerializer(many=True)
    total_price = serializers.SerializerMethodField()
    
    def get_total_price(self, cart: Cart):
        return sum([item.quantity * item.product.unit_price for item in cart.items.all()])
    class Meta:
        model = Cart
        fields = ["id", "items", "total_price"]
"
** views.py
"
class CartViewSet(CreateModelMixin,RetrieveModelMixin, GenericViewSet):
    #* CreateModelMixin: Used to create a model instance using POST method.
    #* RetrieveModelMixin: Used to retrieve a model instance using GET method.
    queryset = Cart.objects.prefetch_related("items__product").all()
    serializer_class = CartSerializer
"

#! Deleting a cart
"
class CartViewSet(
    CreateModelMixin, 
    RetrieveModelMixin, 
    DestroyModelMixin, 
    GenericViewSet
):
    # * CreateModelMixin: Used to create a model instance using POST method.
    # * RetrieveModelMixin: Used to retrieve a model instance using GET method.
    queryset = Cart.objects.prefetch_related("items__product").all()
    serializer_class = CartSerializer
"

#! Getting Individual Cart Items
** views.py
"
class CartItemViewSet(ModelViewSet):
    # queryset = CartItem.objects.all()
    serializer_class = CartItemSerializer
    
    def get_queryset(self):
        return CartItem.objects.filter(cart_id=self.kwargs["cart_pk"]).select_related("product")
"
** urls.py
"
from django.urls import path
from rest_framework_nested import routers
from . import views
from pprint import pprint

router = routers.DefaultRouter()

router.register('products', views.ProductViewSet, basename='products')
router.register('collections', views.CollectionViewSet)
router.register('carts', views.CartViewSet)

products_router = routers.NestedDefaultRouter(router, 'products', lookup='product')
products_router.register('reviews', views.ReviewViewSet, basename='product-reviews')

carts_router = routers.NestedDefaultRouter(router, 'carts', lookup='cart')
carts_router.register('items', views.CartItemViewSet, basename='cart-items')

urlpatterns = router.urls + products_router.urls + carts_router.urls

pprint(urlpatterns)
"

#! Adding a Cart Item
** serializers.py
"
class AddCartItemSerializer(serializers.ModelSerializer):
    product_id = serializers.IntegerField()
    
    #! This is the convention to validate any particular field i.e validate_{field_name}
    def validate_product_id(self, value):
        if not Product.objects.filter(pk=value).exists():
            raise serializers.ValidationError("No product with the given ID was found")
        return value
    
    def save(self, **kwargs):
        cart_id = self.context["cart_id"]
        product_id =self.validated_data['product_id']
        quantity = self.validated_data['quantity']
        try:
            cart_item = CartItem.objects.get(cart_id=cart_id, product_id=product_id)
            cart_item.quantity += quantity
            cart_item.save()
            self.instance = cart_item
        except CartItem.DoesNotExist:
            self.instance = cart_item = CartItem.objects.create(cart_id=cart_id, **self.validated_data)
            
        return self.instance
    
    class Meta:
        model = CartItem
        fields = ["id",  "product_id", "quantity"]
"
** views.py
"
class CartItemViewSet(ModelViewSet):
    # queryset = CartItem.objects.all()
    # serializer_class = CartItemSerializer
    
    def get_serializer_class(self):
        if self.request.method == "POST":
            return AddCartItemSerializer
        return CartItemSerializer

    def get_serializer_context(self):
        return {'cart_id': self.kwargs['cart_pk']}
    
    def get_queryset(self):
        return CartItem.objects.filter(cart_id=self.kwargs["cart_pk"]).select_related("product")
"

#! Updating a Cart Item 
** serializers.py
"
class UpdateCartItemSerializer(serializers.ModelSerializer):
    class Meta:
        model = CartItem
        fields = ["quantity"]
"
** views.py
Add another condition in the if else statement and declare the allowed methods as ["get", "post", "patch", "delete"]
"
#! Getting and Updating Cart Items 
class CartItemViewSet(ModelViewSet):
    http_method_names = ["get", "post", "patch", "delete"]
    # queryset = CartItem.objects.all()
    # serializer_class = CartItemSerializer
    
    def get_serializer_class(self):
        if self.request.method == "POST":
            return AddCartItemSerializer
        elif self.request.method=="PATCH":
            return UpdateCartItemSerializer
        return CartItemSerializer

    def get_serializer_context(self):
        return {'cart_id': self.kwargs['cart_pk']}
    
    def get_queryset(self):
        return CartItem.objects.filter(cart_id=self.kwargs["cart_pk"]).select_related("product")
"

#! Deleting a Cart Item
Already implemented as we are using ModelViewSet in the CartItemViewSet.

----------------------------------------------------------------------------------------------------------------------------

#* Section - 5 (Django Authentication System)
* How the authentication system works
* User model and customizing it
* Extending the User model
* Creating profiles
* Managing groups and permissions

#! Django Authentication System
INSTALLED_APPS contains 'django.contrib.auth' and MIDDLEWARE contains 'django.contrib.auth.middleware.AuthenticationMiddleware'

#! Customizing the User model
There are 2 ways, we can customize the user model
1. Extend the User model using inheritance. This approach should only be used for storing attributes related to authentication. Ex-> 
"class AppUser(AbstractUser): 
    pass
"
2. Create profile which is linked one-to-one to each user in the User Model. This approach should be used for storing non-auth related attributes. Ex->   
"
class Profile(models.Model):
    pass
"

#! Extending the User model
1. It is not possible to create a new CustomUser model in the middle of the project and use it because our migration files are dependent on the default User model.
2. The only way to use the CustomUser model in middle of the project is by droping the database and ingesting data again with the new model. 

Steps:-
* Drop the database and ingest data again
* Create the new model in core app
"
class User(AbstractUser):
    email = models.EmailField(unique=True)
"
* Add "AUTH_USER_MODEL = 'core.User'" in settings.py of storefront2 project directory.
* Change reference from default User model to our new User Model by using "settings.AUTH_USER_MODEL"
"
from django.conf import settings
from django.db import models
# from django.contrib.auth.models import User
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey

class LikedItem(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey()
"

#! Creating User Profiles
Make the following changes in the Customer Model:
"
class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold'),
    ]
    # first_name = models.CharField(max_length=255)
    # last_name = models.CharField(max_length=255)
    # email = models.EmailField(unique=True)
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True, blank=True)
    membership = models.CharField(
        max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    def __str__(self):
        return f'{self.user.first_name} {self.user.last_name}'
    
    @admin.display(ordering='user__first_name')
    def first_name(self):
        return self.user.first_name
    
    @admin.display(ordering='user__last_name')
    def last_name(self):
        return self.user.last_name

    class Meta:
        ordering = ['user__first_name', 'user__last_name']
"
and add the following changes in CustomerAdmin: 
"
@admin.register(models.Customer)
class CustomerAdmin(admin.ModelAdmin):
    list_display = ['first_name', 'last_name',  'membership', 'orders']
    list_editable = ['membership']
    list_per_page = 10
    list_select_related = ['user']
    ordering = ['user__first_name', 'user__last_name']
    search_fields = ['first_name__istartswith', 'last_name__istartswith']
"

#! Groups and Permissions
1. Rather than handling each user individually, we can add them to a group and assign permissions to them.
2. Then go to any particular user and assign that user to a group.
3. Now login using that user's credentials and you will see that that user has access to only the models which are in that group with certain permissions.

#! Creating Custom Permissions
1. We can also add permissions in our models directly.
"
class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)
    customer = models.ForeignKey(Customer, on_delete=models.PROTECT)
    
    class Meta:
        permissions = [
            ('cancel_order', 'Can cancel order')
        ]
"

#* Section - 6 (Securing APIs)
* Token-based authentication
* Adding authentication endpoints
* Registering, logging in, etc.
* Applying permissions

#! Token based authentication
* Let's say the user wants to go to "http://localhost:8000/api/products/", then another request will be sent to "http://localhost:8000/api/auth/" with will check the username and passsword of that user, if that is correct then a token will be returned. Using that token, the user can make any other request to the API.

#! Adding the Authentication Endpoints 
* We know that django comes with an fully-fledged authentication system but this system does not include any api layer i.e endpoints for the user to login, register, etc. We only have a bunch of models, database tables, etc. Now we can build this layer by hand but it will be difficult to maintain it and repetitive.
* Instead we will use DJOSER package to add authentication endpoints. It provides views for user registration, login, logout, etc.
#TODO -> "https://djoser.readthedocs.io/en/latest/index.html"
* pip install -U djoser
* Add 'djoser' in INSTALLED_APPS in settings.py
* Add 'path('auth/', include('djoser.urls')),' to urls.py of the project directory.
Now to implement AUTH ENGINES, we have 2 choices:
a) Token-based authentication which stores token in the database and validates token in every request. This sends request to the backend everytime to validate the token.
b) JSON Web Token authentication which stores a digital signature as token in the browser and validates token in every request. This sends request to the backend only when the token is valid.
* We will use JSON Web Token authentication in our project.
* pip install -U djangorestframework_simplejwt
* Add the following code in settings.py
"
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
}

SIMPLE_JWT = {
   'AUTH_HEADER_TYPES': ('JWT',),
}
"

Available endpoints:
    /users/
    /users/me/
    /users/confirm/
    /users/resend_activation/
    /users/set_password/
    /users/reset_password/
    /users/reset_password_confirm/
    /users/set_username/
    /users/reset_username/
    /users/reset_username_confirm/

    /token/login/ (Token Based Authentication)
    /token/logout/ (Token Based Authentication)
    /jwt/create/ (JSON Web Token Authentication)
    /jwt/refresh/ (JSON Web Token Authentication)
    /jwt/verify/ (JSON Web Token Authentication)

#! Registering Users
When you go to "http://127.0.0.1:8000/auth/users/", we get
"
HTTP 401 Unauthorized
Allow: GET, POST, HEAD, OPTIONS
Content-Type: application/json
Vary: Accept
WWW-Authenticate: JWT realm="api"

{
    "detail": "Authentication credentials were not provided."
}
"
Here we can see that it accepts POST request, so we can register a new user.
When I send post request with body
"
{
    "email": "user1@domain.com",
    "username": "user1",
    "password": "1234"
}
"
I get 400 Bad request
"
HTTP 400 Bad Request
Allow: GET, POST, HEAD, OPTIONS
Content-Type: application/json
Vary: Accept

{
    "password": [
        "This password is too short. It must contain at least 8 characters.",
        "This password is too common.",
        "This password is entirely numeric."
    ]
}
"
So provide a good password and a new user wwill be registered.

#TODO -> How to send first_name and last_name in POST request?
Ans) We need to have a custom serializer to send the first_name and last_name in POST request.

#TODO -> Refer => "https://djoser.readthedocs.io/en/latest/settings.html#serializers"
#TODO -> Refer => "https://stackoverflow.com/questions/49095424/customize-the-djoser-create-user-endpoint"

#? These are the default serializers provided by djoser
"
{
    'activation': 'djoser.serializers.ActivationSerializer',
    'password_reset': 'djoser.serializers.SendEmailResetSerializer',
    'password_reset_confirm': 'djoser.serializers.PasswordResetConfirmSerializer',
    'password_reset_confirm_retype': 'djoser.serializers.PasswordResetConfirmRetypeSerializer',
    'set_password': 'djoser.serializers.SetPasswordSerializer',
    'set_password_retype': 'djoser.serializers.SetPasswordRetypeSerializer',
    'set_username': 'djoser.serializers.SetUsernameSerializer',
    'set_username_retype': 'djoser.serializers.SetUsernameRetypeSerializer',
    'username_reset': 'djoser.serializers.SendEmailResetSerializer',
    'username_reset_confirm': 'djoser.serializers.UsernameResetConfirmSerializer',
    'username_reset_confirm_retype': 'djoser.serializers.UsernameResetConfirmRetypeSerializer',
    'user_create': 'djoser.serializers.UserCreateSerializer',
    'user_create_password_retype': 'djoser.serializers.UserCreatePasswordRetypeSerializer',
    'user_delete': 'djoser.serializers.UserDeleteSerializer',
    'user': 'djoser.serializers.UserSerializer',
    'current_user': 'djoser.serializers.UserSerializer',
    'token': 'djoser.serializers.TokenSerializer',
    'token_create': 'djoser.serializers.TokenCreateSerializer',
}
"

* Step-1: Create a custom serializer in serializers.py from core app
"
from djoser.serializers import UserCreateSerializer as BaseUserCreateSerializer


class UserCreateSerializer(BaseUserCreateSerializer):
    class Meta(BaseUserCreateSerializer.Meta):
        fields = ["id", "username", "password", "email", "first_name", "last_name"]

"
* Step-2: Add the custom serializer in settings.py of the project i.e storefront2
"
DJOSER = {
    'SERIALIZERS': {
        'user_create': 'core.serializers.UserCreateSerializer',  
    }
}
"
Now when you go to "http://127.0.0.1:8000/auth/users/", we get
"
{
    "username": "",
    "password": "",
    "email": "",
    "first_name": "",
    "last_name": ""
}
"

#! EACH COMPONENT SHOULD HAVE A SINGLE RESPONSIBILITY
