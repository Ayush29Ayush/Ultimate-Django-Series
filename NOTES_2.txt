This this the second part of the series which will be continued from where the first part ended.

#* Section - 1 (Setting Up the Project and Database)

#! Set up the database and code for the project
1. Open MySQL Workbench and create a new database named storefront2.
2. Run "python manage.py makemigrations" and "python manage.py migrate" to create the tables in the database.
3. Now go to Server option and click in Data Import, then select the seed2 and storefront2 database. Click start import.
4. Create superuser for the admin panel.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#* Section - 2 (RESTful APIs)

#! What are RESTful APIs 
* API stands for Application Programming Interface.
* API is a set of instructions that a server uses to understand and respond to a request. * It is dynamic in nature and can be used to interact with any web service.
* Different endpoints in an API results in different actions.
* It is a standard that defines how a server should respond to a request.

* RESTful API means Representational State Transfer (REST).
* RESTful APIs has many benifits like they are fast, secure, scalability, maintainability, easy to understand and easy to change.

** Main 3 things in RESTful API are --> resources, representations and HTTP methods.

#! Resources
A resource in an API is just like a application in our project like "Products", "Collections", "Tags", "Carts", "Orders", "Customers".
* Resources are just collection of data.
* Resources are identified by their URLs (Uniform Resource Locator).

#! Resource Representations
* A resource representation is a representation of a resource in a particular format.
* A resource representation is identified by its pattern.

#! HTTP Methods
* HTTP methods are a set of verbs that a server can use to perform various actions on a resource.
* HTTP methods are identified by their name.
* HTTP methods --> GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD

#! Install Django REST framework
1. pip install djangorestframework
2. Add 'rest_framework' to INSTALLED_APPS in settings.py

#! Creating API views
1. In views.py from store app, create a view named product_list and link it with a url "products/" in urls.py
"
from django.shortcuts import render
from django.http import HttpResponse

def product_list(request):
    return HttpResponse("You're at the store product list.")
"
2. Add "path('store/', include('store.urls'))," to urls.py of the project directory.

Django has "HttpRequest" and "HttpResponse" classes.
REST Framework has "Request" and "Response" classes, which are much simpler but more powerful. 

3. Use "from rest_framework.decorators import api_view" to overwrite the default Django request with REST framework request.
4. Use "from rest_framework.response import Response" to overwrite the default Django response with REST framework response.
5. Now we get a browsable API at "http://127.0.0.1:8000/store/products/"

** views.py
"
from django.shortcuts import render
from django.http import HttpResponse
from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view()
def product_list(request):
    return Response("You're at the store product list.")

@api_view()
def product_detail(request, id):
    return Response(id)
"

** urls.py
"
from django.urls import path
from . import views

urlpatterns = [
    path('products/', views.product_list),
    path('products/<int:id>/', views.product_detail),
]
"

#! Creating Serializers
"
from rest_framework import serializers

class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)
"

* Add the following code in the project settings.py to change the default behaviour of the serializer to change integer to string
"
REST_FRAMEWORK = {
    'COERCE_DECIMAL_TO_STRING': False
}
"

** views.py
"
@api_view()
def product_detail(request, id):
    try:
        product = Product.objects.get(pk=id)
        serializer = ProductSerializer(product)
        return Response(serializer.data)
    except Product.DoesNotExist:
        return Response(status=status.HTTP_404_NOT_FOUND)
"
Alternatively, use "from django.shortcuts import get_object_or_404"
"
@api_view()
def product_detail(request, id):
    product = get_object_or_404(Product, pk=id)
    serializer = ProductSerializer(product)
    return Response(serializer.data)
"

* Add many=True in ProductSerializer to get all the products
"
@api_view()
def product_list(request):
    queryset = Product.objects.all()
    serializer = ProductSerializer(queryset, many=True)
    return Response(serializer.data)
"

#! Creating Custom Serializer Fields 
** serializers.py
"
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price')
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"
* Here we have renamed the unit_price field to price.
* We also added a new custom field "price_with_tax" which is calculated using calculate_tax method.

#! Serializing Relationships 
There are 4 ways to serialize the relationship between 2 models:-
#? Primary Key
#? String
#? Nested object
#? Hyperlink

Here we are serializing the relationship between Product and Collection.
1. Method - 1: To get the relationship between Product and Collection, we use "PrimaryKeyRelatedField" in ProductSerializer.
"
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price')
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    collection = serializers.PrimaryKeyRelatedField(
        queryset=Collection.objects.all()
    )

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"

2. Method - 2: Here we are serializing the relationship between Product and Collection using "StringRelatedField" in ProductSerializer, this will return the title of the collection.

* Add "queryset = Product.objects.select_related('collection').all()" in the view to get the collection title of the product faster else for 1000 records it will execute 1000 queries to the database.
"
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price')
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    collection = serializers.StringRelatedField()

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"
3. Method - 3: Here we using nested serializer concept
"
class CollectionSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)


class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(
        max_digits=6, decimal_places=2, source="unit_price"
    )
    price_with_tax = serializers.SerializerMethodField(method_name="calculate_tax")
    collection = CollectionSerializer()

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"

4. Method - 4: Here we use HyperlinkedRelatedField to get the relationship between Product and Collection
** serializers.py
"
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(
        max_digits=6, decimal_places=2, source="unit_price"
    )
    price_with_tax = serializers.SerializerMethodField(method_name="calculate_tax")
    collection = serializers.HyperlinkedRelatedField(
        queryset=Collection.objects.all(),
        view_name="collection-detail",
    )

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"
** views.py
"
@api_view()
def collection_detail(request, pk):
    return Response(f"Collection {pk}")
"
** urls.py
"
urlpatterns = [
    path('products/', views.product_list),
    path('products/<int:id>/', views.product_detail),
    path('collections/<int:pk>/', views.collection_detail, name='collection-detail'),
]
"

#! Model Serializers
"
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ["id", "title", "unit_price", "price_with_tax", "collection"]
        # fields = ['id', 'title', 'price', 'collection']

    # price = serializers.DecimalField(max_digits=6, decimal_places=2, source="unit_price")
    price_with_tax = serializers.SerializerMethodField(method_name="calculate_tax")

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"

#! Deserializing Objects and Data Validation
1. Deserialization is the process of converting a JSON object into a Python object.
2. It is the opposite of serializing.
3. It happens when the server gets data from a client.

4. Method - 1
"
@api_view(["GET", "POST"])
def product_list(request):
    if request.method == "GET":
        queryset = Product.objects.select_related("collection").all()
        serializer = ProductSerializer(
            queryset, many=True, context={"request": request}
        )
        return Response(serializer.data)
    elif request.method == "POST":
        serializer = ProductSerializer(data=request.data)
        if serializer.is_valid():
            print(serializer.validated_data)
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        else:
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
"
5. Method - 2 : rather than using this if else block for validating data, we can use "is_valid(raise_exception=True)"
"
@api_view(["GET", "POST"])
def product_list(request):
    if request.method == "GET":
        queryset = Product.objects.select_related("collection").all()
        serializer = ProductSerializer(
            queryset, many=True, context={"request": request}
        )
        return Response(serializer.data)
    elif request.method == "POST":
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        print(serializer.validated_data)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)
"

#! Saving Objects
Data to create using POST
"
{
   "title": "a",
   "slug": "a",
   "unit_price": 1,
   "collection": 1,
   "inventory": 1
}
"
** serializers.py
"
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ["id", "title", "description", "slug", "inventory", "unit_price", "price_with_tax", "collection"]

    price_with_tax = serializers.SerializerMethodField(method_name="calculate_tax")

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
"

** views.py
"
@api_view(["GET", "POST"])
def product_list(request):
    if request.method == "GET":
        queryset = Product.objects.select_related("collection").all()
        serializer = ProductSerializer(
            queryset, many=True, context={"request": request}
        )
        return Response(serializer.data)
    elif request.method == "POST":
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        print(serializer.validated_data)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)


@api_view(["GET", "PUT"])
def product_detail(request, id):
    if request.method == "GET":
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product)
        return Response(serializer.data)
    elif request.method == "PUT":
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)
"

#! Deleting Objects
** models.py
"class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.PROTECT)
    product = models.ForeignKey(Product, on_delete=models.PROTECT, related_name='orderitems')
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6, decimal_places=2)
"
** views.py
"
@api_view(["GET", "PUT", "DELETE"])
def product_detail(request, id):
    if request.method == "GET":
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product)
        return Response(serializer.data)
    elif request.method == "PUT":
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)
    elif request.method == "DELETE":
        product = get_object_or_404(Product, pk=id)
        
        if product.orderitems.count() > 0:
            return Response({"error": "Product cannot be deleted because it is associated with an order item."}, status=status.HTTP_405_METHOD_NOT_ALLOWED)

        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
"

#! Exercise- Building the Collections API
Ques) Implement the Collection API similar to the Product API
Ans)

** models.py -> we added a related_name="products" in the Product model to get the products in the collection using COUNT.
"
class Product(models.Model):
    title = models.CharField(max_length=255)
    slug = models.SlugField()
    description = models.TextField(null=True, blank=True)
    unit_price = models.DecimalField(
        max_digits=6,
        decimal_places=2,
        validators=[MinValueValidator(1)])
    inventory = models.IntegerField(validators=[MinValueValidator(0)])
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT, related_name='products')
    promotions = models.ManyToManyField(Promotion, blank=True)

    def __str__(self) -> str:
        return self.title

    class Meta:
        ordering = ['title']
"
** views.py
"
@api_view(["GET", "POST"])
def collection_list(request):
    if request.method == "GET":
        queryset = Collection.objects.annotate(products_count=Count("products")).all()
        serializer = CollectionSerializer(queryset, many=True)
        return Response(serializer.data)
    elif request.method == "POST":
        serializer = CollectionSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)


@api_view(["GET", "PUT", "DELETE"])
def collection_detail(request, pk):
    # collection = get_object_or_404(Collection, pk=pk) // gives error because products_count is not defined by default but is required in CollectionSerializer
    collection = get_object_or_404(
        Collection.objects.annotate(products_count=Count("products")).all(), pk=pk
    )
    if request.method == "GET":
        serializer = CollectionSerializer(collection)
        return Response(serializer.data)
    elif request.method == "PUT":
        serializer = CollectionSerializer(collection, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)
    elif request.method == "DELETE":
        if collection.products.count() > 0:
            return Response(
                {
                    "error": "Collection cannot be deleted because it includes one or more products."
                },
                status=status.HTTP_405_METHOD_NOT_ALLOWED,
            )
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
"
** serializers.py
"
class CollectionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Collection
        fields = ["id", "title", "products_count"]
        
    products_count = serializers.IntegerField(read_only=True)
"
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#* Section - 3 (Advanced API concepts)
* Class-based views
* Generic views
* Viewsets
* Routers
* Searching, filtering, pagination, etc.

#! Class-based views
1. All the API views we created till now were functional based views but django also supports class-based views which promote reusability and modularity. They are prefered over functional based views.
2. The class-based views have a particular naming convention i.e Capital letters and without any underscores.
3. The functional-based views have a particular naming convention i.e lowercase letters and with underscores.

** views.py
"
class ProductList(APIView):
    def get(self, request):
        queryset = Product.objects.select_related("collection").all()
        serializer = ProductSerializer(
            queryset, many=True, context={"request": request}
        )
        return Response(serializer.data)

    def post(self, request):
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        print(serializer.validated_data)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)


class ProductDetail(APIView):
    def get(self, request, id):
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product)
        return Response(serializer.data)

    def put(self, request, id):
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)

    def delete(self, request, id):
        product = get_object_or_404(Product, pk=id)
        if product.orderitems.count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                },
                status=status.HTTP_405_METHOD_NOT_ALLOWED,
            )
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)


class CollectionList(APIView):
    def get(self, request):
        queryset = Collection.objects.annotate(products_count=Count("products")).all()
        serializer = CollectionSerializer(queryset, many=True)
        return Response(serializer.data)

    def post(self, request):
        serializer = CollectionSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)


class CollectionDetail(APIView):
    def get(self, request, pk):
        collection = get_object_or_404(
            Collection.objects.annotate(products_count=Count("products")).all(), pk=pk
        )
        serializer = CollectionSerializer(collection)
        return Response(serializer.data)

    def put(self, request, pk):
        collection = get_object_or_404(
            Collection.objects.annotate(products_count=Count("products")).all(), pk=pk
        )
        serializer = CollectionSerializer(collection, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)

    def delete(self, request, pk):
        collection = get_object_or_404(
            Collection.objects.annotate(products_count=Count("products")).all(), pk=pk
        )
        if collection.products_count > 0:
            return Response(
                {
                    "error": "Collection cannot be deleted because it includes one or more products."
                },
                status=status.HTTP_405_METHOD_NOT_ALLOWED,
            )
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
"
** urls.py
"
urlpatterns = [
    path('products/', views.ProductList.as_view()),
    path('products/<int:id>/', views.ProductDetail.as_view()),
    path('collections/<int:pk>/', views.CollectionDetail.as_view(), name='collection-detail'),
    path('collections/', views.CollectionList.as_view()),
]
"

#! Mixins 
Link -> "https://www.django-rest-framework.org/api-guide/generic-views/"
* Pretty much similar to our implementation in views till now.

#! Generic Views 
Most Common Generic Views are "ListCreateAPIView" and "RetrieveUpdateDestroyAPIView"

* Rather than using mixins directly, we use concrete classes like "Generic Views".
* Generic views are used to implement common operations like searching, filtering, ordering, pagination, etc.
Here we re-write the ProductList and CollectionList views using generic views -> "ListCreateAPIView"
"
class ProductList(ListCreateAPIView):
    queryset = Product.objects.select_related("collection").all()
    serializer_class = ProductSerializer

    def get_serializer_context(self):
        return {"request": self.request}

class CollectionList(ListCreateAPIView):
    queryset = Collection.objects.annotate(products_count=Count("products")).all()
    serializer_class = CollectionSerializer
    
    def get_serializer_context(self):
        return {"request": self.request}
"

#! Customizing Generic Views
Here we are using "RetrieveUpdateDestroyAPIView" which is a class that extends the generic views. It allows us to get, update and delete objects. Since we have a custom logic for delete, we overwrite the "delete" method.
Since these generic views use "pk" instead of "id", we have used "pk" through out the code.
** views.py
"
class ProductDetail(RetrieveUpdateDestroyAPIView):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    
    # def get(self, request, id):
    #     product = get_object_or_404(Product, pk=id)
    #     serializer = ProductSerializer(product)
    #     return Response(serializer.data)

    # def put(self, request, id):
    #     product = get_object_or_404(Product, pk=id)
    #     serializer = ProductSerializer(product, data=request.data)
    #     serializer.is_valid(raise_exception=True)
    #     serializer.save()
    #     return Response(serializer.data)

    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                },
                status=status.HTTP_405_METHOD_NOT_ALLOWED,
            )
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

class CollectionDetail(RetrieveUpdateDestroyAPIView):
    queryset = Collection.objects.annotate(products_count=Count("products")).all()
    serializer_class = CollectionSerializer

    def delete(self, request, pk):
        collection = get_object_or_404(
            Collection.objects.annotate(products_count=Count("products")).all(), pk=pk
        )
        if collection.products_count > 0:
            return Response(
                {
                    "error": "Collection cannot be deleted because it includes one or more products."
                },
                status=status.HTTP_405_METHOD_NOT_ALLOWED,
            )
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
"

** urls.py
"
urlpatterns = [
    path('products/', views.ProductList.as_view()),
    path('products/<int:pk>/', views.ProductDetail.as_view()),
    path('collections/<int:pk>/', views.CollectionDetail.as_view(), name='collection-detail'),
    path('collections/', views.CollectionList.as_view()),
]
"

#! ViewSets
Most common ViewSets are "ModelViewSet" and "GenericViewSet"
* Naming convention is similar to generic views -> "ModelViewSet" will be "ProductViewSet"
* It is just a class which has all the features of generic views and mixins.
* Now rather than using 2 classes "ProductList" and "ProductDetail" in views.py, we can use "ProductViewSet" in views.py

** views.py
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                },
                status=status.HTTP_405_METHOD_NOT_ALLOWED,
            )
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)


class CollectionViewSet(ModelViewSet):
    queryset = Collection.objects.annotate(products_count=Count("products")).all()
    serializer_class = CollectionSerializer
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def delete(self, request, pk):
        collection = get_object_or_404(
            Collection.objects.annotate(products_count=Count("products")).all(), pk=pk
        )
        if collection.products_count > 0:
            return Response(
                {
                    "error": "Collection cannot be deleted because it includes one or more products."
                },
                status=status.HTTP_405_METHOD_NOT_ALLOWED,
            )
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
"

#! Routers
There are 2 types of routers -> "DefaultRouter" and "SimpleRouter"
* DefaultRouter gives us the ability to use "ModelViewSet" and "GenericViewSet" in views.py
* SimpleRouter gives us all the routes for that project in urls.py

Using DefaultRouter, we get:
"
HTTP 200 OK
Allow: GET, HEAD, OPTIONS
Content-Type: application/json
Vary: Accept

{
    "products": "http://127.0.0.1:8000/store/products/",
    "collections": "http://127.0.0.1:8000/store/collections/"
}
"
"

Using SimpleRouter, we get these from router.urls:
"
[<URLPattern '^products/$' [name='product-list']>,
 <URLPattern '^products/(?P<pk>[^/.]+)/$' [name='product-detail']>,
 <URLPattern '^collections/$' [name='collection-list']>,
 <URLPattern '^collections/(?P<pk>[^/.]+)/$' [name='collection-detail']>]
"

** urls.py
"
from django.urls import path
from rest_framework.routers import SimpleRouter, DefaultRouter
from . import views
from pprint import pprint

router = SimpleRouter()

router.register('products', views.ProductViewSet)
router.register('collections', views.CollectionViewSet)

pprint(router.urls)

# URLConf
# urlpatterns = [
    # path('products/', views.ProductList.as_view()),
    # path('products/<int:pk>/', views.ProductDetail.as_view()),
    # path('collections/<int:pk>/', views.CollectionDetail.as_view(), name='collection-detail'),
    # path('collections/', views.CollectionList.as_view()),
# ]

urlpatterns = router.urls
"

Since we are using ModelViewSet, destroy is used instead of delete.
** views.py
"
from django.shortcuts import render, get_object_or_404
from django.http import HttpResponse
from django.db.models import Count
from rest_framework.mixins import ListModelMixin, CreateModelMixin
from rest_framework.generics import ListCreateAPIView, RetrieveUpdateDestroyAPIView
from rest_framework.viewsets import ModelViewSet
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework import status
from store.models import Collection, OrderItem, Product
from store.serializers import CollectionSerializer, ProductSerializer


class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                }
            )
        return super().destroy(request, *args, **kwargs)
    
    # def delete(self, request, pk):
    #     product = get_object_or_404(Product, pk=pk)
    #     if product.orderitems.count() > 0:
    #         return Response(
    #             {
    #                 "error": "Product cannot be deleted because it is associated with an order item."
    #             },
    #             status=status.HTTP_405_METHOD_NOT_ALLOWED,
    #         )
    #     product.delete()
    #     return Response(status=status.HTTP_204_NO_CONTENT)


class CollectionViewSet(ModelViewSet):
    queryset = Collection.objects.annotate(products_count=Count("products")).all()
    serializer_class = CollectionSerializer
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if Product.objects.filter(collection_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Collection cannot be deleted because it includes one or more products."
                }
            )
            
        return super().destroy(request, *args, **kwargs)
    
    # def delete(self, request, pk):
    #     collection = get_object_or_404(
    #         Collection.objects.annotate(products_count=Count("products")).all(), pk=pk
    #     )
    #     if collection.products_count > 0:
    #         return Response(
    #             {
    #                 "error": "Collection cannot be deleted because it includes one or more products."
    #             },
    #             status=status.HTTP_405_METHOD_NOT_ALLOWED,
    #         )
    #     collection.delete()
    #     return Response(status=status.HTTP_204_NO_CONTENT)

"

#! Building the Reviews API 
Step-1
* Create a review model
* Run makemigrations
* Migrate

Step-2
* Create a ReviewSerializer
* Create a view
* Register a route

#! Nested Routers 
For urls like "products/<int:pk>/reviews/", we can use NestedRouters.
Refer => "https://pypi.org/project/drf-nested-routers/" and "https://github.com/alanjds/drf-nested-routers"
* pip install drf-nested-routers

Create a new serializer for reviews:
"
class ReviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = Review
        fields = ["id", "date", "name", "description"]
        # fields = ["id", "date", "name", "description", "product"]
        
    def create(self, validated_data):
        product_id = self.context["product_id"]
        return Review.objects.create(product_id=product_id, **validated_data)
"

Create a new view for reviews:
"
class ReviewViewSet(ModelViewSet):
    # queryset = Review.objects.all()
    serializer_class = ReviewSerializer
    
    #! This is same as defining queryset but since we want the Reviews to be filtered acc to the pk, we will overwrite the default get_queryset()
    def get_queryset(self):
        # print(self.kwargs)
        return Review.objects.filter(product_id=self.kwargs["product_pk"])
    
    #! Since we do not want to pass the product id manually and want it to be taken from the url, pass the url details as context
    def get_serializer_context(self):
        print(self.kwargs)
        return {"product_id": self.kwargs["product_pk"]}
"

Then go to "store/urls.py" and write the following code:
"
from django.urls import path
# from rest_framework.routers import SimpleRouter, DefaultRouter
from rest_framework_nested import routers
from . import views
from pprint import pprint

router = routers.DefaultRouter()

router.register('products', views.ProductViewSet)
router.register('collections', views.CollectionViewSet)

products_router = routers.NestedDefaultRouter(router, 'products', lookup='product')
products_router.register('reviews', views.ReviewViewSet, basename='product-reviews')

urlpatterns = router.urls + products_router.urls

# pprint(router.urls)
pprint(urlpatterns)
"

#! Filtering Data
Since we want the filtering to happen in Product API when any collection_id is passed as a params in the url, we will overwrite the default get_queryset() method in ProductViewSet
"
class ProductViewSet(ModelViewSet):
    # queryset = Product.objects.all()
    serializer_class = ProductSerializer
    
    def get_queryset(self):
        pprint(self)
        queryset = Product.objects.all()
        # collection_id = self.request.query_params['collection_id']
        collection_id = self.request.query_params.get('collection_id')
        
        if collection_id is not None:
            queryset = queryset.filter(collection_id=collection_id)
        
        return queryset
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                }
            )
        return super().destroy(request, *args, **kwargs)
"
#? but after removing the queryset field from the ProductViewSet, we will get an error as shown below:
"
File "D:\Ultimate-Django-Series\venv\Lib\site-packages\rest_framework\routers.py", line 170, in get_default_basename
    assert queryset is not None, '`basename` argument not specified, and could ' \
AssertionError: `basename` argument not specified, and could not automatically determine the name from the viewset, as it does not have a `.queryset` attribute.
"
#? Read this error carefully, to fix it add a basename in the url for products "router.register('products', views.ProductViewSet, basename='products')" and rerun the server.

#! Generic Filtering 
It is getting very complex to apply the filter logic with ModelViewSet, so we can use generic filters like "django_filters"
1. pip install django-filter
2. Using this, we can completely remove the get_queryset() logic, just add filter_backends and filterset_fields.
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['collection_id']
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                }
            )
        return super().destroy(request, *args, **kwargs)
"
3. If we want to filter the products based on a range of unit_price, we can use django_filters but with custom filters.
4. Create a filters.py file in the store folder and write the following code:
** filters.py
"
from django_filters.rest_framework import FilterSet
from store.models import Product

class ProductFilter(FilterSet):
    class Meta:
        model = Product
        fields = {
            'collection_id': ['exact'],
            'unit_price': ['gt', 'lt']
        }
"
** views.py
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_class = ProductFilter
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                }
            )
        return super().destroy(request, *args, **kwargs)
"

#! Searching
* import statement: "from rest_framework.filters import SearchFilter"
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_class = ProductFilter
    # Search_fields = ["title", "description", 'collection__title']
    search_fields = ["title", "description"]
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                }
            )
        return super().destroy(request, *args, **kwargs)
"

#! Sorting
* import statement: "from rest_framework.filters import OrderingFilter"
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    # Search_fields = ["title", "description", 'collection__title']
    search_fields = ["title", "description"]
    ordering_fields = ["unit_price", "last_update"]
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                }
            )
        return super().destroy(request, *args, **kwargs)
"

#! Pagination
* import statement: "from rest_framework.pagination import PageNumberPagination"
** views.py
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    search_fields = ["title", "description"]
    ordering_fields = ["unit_price", "last_update"]
    pagination_class = PageNumberPagination 
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                }
            )
        return super().destroy(request, *args, **kwargs)

"
but if you want more control on the pagination, you can create a pagination.py file and write the following code:
"
from rest_framework.pagination import PageNumberPagination

class DefaultPagination(PageNumberPagination):
    page_size = 10
    page_size_query_param = 'page_size'
    max_page_size = 123
"
then we would not require the import statement: "from rest_framework.pagination import PageNumberPagination"
** views.py
"
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    search_fields = ["title", "description"]
    ordering_fields = ["unit_price", "last_update"]
    # pagination_class = PageNumberPagination 
    pagination_class = DefaultPagination 
    
    def get_serializer_context(self):
        return {"request": self.request}
    
    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response(
                {
                    "error": "Product cannot be deleted because it is associated with an order item."
                }
            )
        return super().destroy(request, *args, **kwargs)
"

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#* Section - 4 (Designing a shopping Cart API)
#! Operations needed to design a shopping cart API:-
* Create a cart
* Add items to a cart
* Update the quantity of items
* Remove items from a cart
* Get a cart with its items
* Delete a cart

#! For each operation, specify the following:-
* Method
* url endpoints
* request body
* response body

a) Creating a cart
* Method -> POST
* url endpoint -> /carts/
* request body -> None
* response body -> Cart object

b) Getting a cart
* Method -> GET
* url endpoint -> /carts/{id}/
* request body -> None
* response body -> Cart object

c) Deleting a cart
* Method -> DELETE
* url endpoint -> /carts/{id}/
* request body -> None
* response body -> None

d) Adding items to a cart
* Method -> POST
* url endpoint -> /carts/{id}/items/
* request body -> Item object -> {"product_id": 1, "quantity": 2}
* response body -> Item object

e) Updating the item
* Method -> PATCH in place of PUT because we want to update the quantity only and not the whole item
* url endpoint -> /carts/{id}/items/{item_id}/
* request body -> Item object -> {"quantity": 3}
* response body -> Item object -> {"product_id": 1, "quantity": 3}

f) Deleting an item
* Method -> DELETE
* url endpoint -> /carts/{id}/items/{item_id}/
* request body -> None
* response body -> None

So in total there will be 2 ViewSets:
a) "CartViewSet" contains "/carts" and "/carts/:id"
b) "CartItemViewSet" contains "/carts/:id/items" and "/carts/:id/items/:item_id"

#! Revisiting the Data Model
"class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)"
1. Our cart model contains pk i.e the "id" and "created_at" but the hacker can easily guess numbers like 1,2,3,etc in urls like "/carts/1/", "/carts/2/", "/carts/3/", etc.
2. To prevent this, we willl use GUID (Globally Unique Identifier) instead of default pk i.e the "id".
3. Now our url will look like "/carts/7b7b5b5b-7b5b-7b5b-7b5b-7b5b7b5b7b5b/"
4. Now our cart model looks like:
"
from uuid import uuid4

class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4)
    created_at = models.DateTimeField(auto_now_add=True)
"
5. Also make changes in CartItem model by adding a related_name and unique_together so that no 2 products can be added to the same cart.
"
class CartItem(models.Model):
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE, related_name='items') # By default, it was 'cartitem_set'
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()
    
    class Meta:
        unique_together = [['cart', 'product']]
"
6. Run commands "python manage.py makemigrations" and "python manage.py migrate" for these changes to be reflected in the database.

#! Creating a Cart 
Step - 1: Create a serializer
Step - 2: Create a viewset
Step - 3: Create a route

#? ModelViewSet: A viewset that provides default create(), retrieve(), update(), partial_update(), destroy() and list() actions.
#! Since we only need operations like "Creating a cart", "Getting a cart", "Deleting a cart" using POST, GET using id and DELETE methods, we will not use ModelViewSet because it will provide us with list and update methods which will expose all our data in the API. To prevent this, we will create a custom ViewSet.
#TODO : Create a custom ViewSet by combining various mixins and generic view set. Click on "ModelViewSet" using "Ctrl+Click" to see its implementation.
** serializers.py
"
class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)
    class Meta:
        model = Cart
        fields = ["id"]
"

** views.py
"
class CartViewSet(CreateModelMixin, GenericViewSet):
    #* CreateModelMixin: Used to create a model instance using POST method.
    queryset = Cart.objects.all()
    serializer_class = CartSerializer
"

** urls.py
"
router.register('carts', views.CartViewSet)
"

#! Getting a cart
We need a GET method to get the cart instance

** serializers.py
"
class SimpleProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ["id", "title", "unit_price"]
    
    
class CartItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer()
    total_price = serializers.SerializerMethodField()
    
    def get_total_price(self, cart_item: CartItem):
        return cart_item.quantity * cart_item.product.unit_price
    class Meta:
        model = CartItem
        fields = ["id", "product", "quantity", "total_price"]
        
        
class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)
    items = CartItemSerializer(many=True)
    total_price = serializers.SerializerMethodField()
    
    def get_total_price(self, cart: Cart):
        return sum([item.quantity * item.product.unit_price for item in cart.items.all()])
    class Meta:
        model = Cart
        fields = ["id", "items", "total_price"]
"
** views.py
"
class CartViewSet(CreateModelMixin,RetrieveModelMixin, GenericViewSet):
    #* CreateModelMixin: Used to create a model instance using POST method.
    #* RetrieveModelMixin: Used to retrieve a model instance using GET method.
    queryset = Cart.objects.prefetch_related("items__product").all()
    serializer_class = CartSerializer
"

#! Deleting a cart
"
class CartViewSet(
    CreateModelMixin, 
    RetrieveModelMixin, 
    DestroyModelMixin, 
    GenericViewSet
):
    # * CreateModelMixin: Used to create a model instance using POST method.
    # * RetrieveModelMixin: Used to retrieve a model instance using GET method.
    queryset = Cart.objects.prefetch_related("items__product").all()
    serializer_class = CartSerializer
"

#! Getting Individual Cart Items
** views.py
"
class CartItemViewSet(ModelViewSet):
    # queryset = CartItem.objects.all()
    serializer_class = CartItemSerializer
    
    def get_queryset(self):
        return CartItem.objects.filter(cart_id=self.kwargs["cart_pk"]).select_related("product")
"
** urls.py
"
from django.urls import path
from rest_framework_nested import routers
from . import views
from pprint import pprint

router = routers.DefaultRouter()

router.register('products', views.ProductViewSet, basename='products')
router.register('collections', views.CollectionViewSet)
router.register('carts', views.CartViewSet)

products_router = routers.NestedDefaultRouter(router, 'products', lookup='product')
products_router.register('reviews', views.ReviewViewSet, basename='product-reviews')

carts_router = routers.NestedDefaultRouter(router, 'carts', lookup='cart')
carts_router.register('items', views.CartItemViewSet, basename='cart-items')

urlpatterns = router.urls + products_router.urls + carts_router.urls

pprint(urlpatterns)
"

#! Adding a Cart Item
** serializers.py
"
class AddCartItemSerializer(serializers.ModelSerializer):
    product_id = serializers.IntegerField()
    
    #! This is the convention to validate any particular field i.e validate_{field_name}
    def validate_product_id(self, value):
        if not Product.objects.filter(pk=value).exists():
            raise serializers.ValidationError("No product with the given ID was found")
        return value
    
    def save(self, **kwargs):
        cart_id = self.context["cart_id"]
        product_id =self.validated_data['product_id']
        quantity = self.validated_data['quantity']
        try:
            cart_item = CartItem.objects.get(cart_id=cart_id, product_id=product_id)
            cart_item.quantity += quantity
            cart_item.save()
            self.instance = cart_item
        except CartItem.DoesNotExist:
            self.instance = cart_item = CartItem.objects.create(cart_id=cart_id, **self.validated_data)
            
        return self.instance
    
    class Meta:
        model = CartItem
        fields = ["id",  "product_id", "quantity"]
"
** views.py
"
class CartItemViewSet(ModelViewSet):
    # queryset = CartItem.objects.all()
    # serializer_class = CartItemSerializer
    
    def get_serializer_class(self):
        if self.request.method == "POST":
            return AddCartItemSerializer
        return CartItemSerializer

    def get_serializer_context(self):
        return {'cart_id': self.kwargs['cart_pk']}
    
    def get_queryset(self):
        return CartItem.objects.filter(cart_id=self.kwargs["cart_pk"]).select_related("product")
"

#! Updating a Cart Item 
** serializers.py
"
class UpdateCartItemSerializer(serializers.ModelSerializer):
    class Meta:
        model = CartItem
        fields = ["quantity"]
"
** views.py
Add another condition in the if else statement and declare the allowed methods as ["get", "post", "patch", "delete"]
"
#! Getting and Updating Cart Items 
class CartItemViewSet(ModelViewSet):
    http_method_names = ["get", "post", "patch", "delete"]
    # queryset = CartItem.objects.all()
    # serializer_class = CartItemSerializer
    
    def get_serializer_class(self):
        if self.request.method == "POST":
            return AddCartItemSerializer
        elif self.request.method=="PATCH":
            return UpdateCartItemSerializer
        return CartItemSerializer

    def get_serializer_context(self):
        return {'cart_id': self.kwargs['cart_pk']}
    
    def get_queryset(self):
        return CartItem.objects.filter(cart_id=self.kwargs["cart_pk"]).select_related("product")
"

#! Deleting a Cart Item
Already implemented as we are using ModelViewSet in the CartItemViewSet.

----------------------------------------------------------------------------------------------------------------------------

#* Section - 5 (Django Authentication System)
* How the authentication system works
* User model and customizing it
* Extending the User model
* Creating profiles
* Managing groups and permissions

#! Django Authentication System
INSTALLED_APPS contains 'django.contrib.auth' and MIDDLEWARE contains 'django.contrib.auth.middleware.AuthenticationMiddleware'

#! Customizing the User model
There are 2 ways, we can customize the user model
1. Extend the User model using inheritance. This approach should only be used for storing attributes related to authentication. Ex-> 
"class AppUser(AbstractUser): 
    pass
"
2. Create profile which is linked one-to-one to each user in the User Model. This approach should be used for storing non-auth related attributes. Ex->   
"
class Profile(models.Model):
    pass
"

#! Extending the User model
1. It is not possible to create a new CustomUser model in the middle of the project and use it because our migration files are dependent on the default User model.
2. The only way to use the CustomUser model in middle of the project is by droping the database and ingesting data again with the new model. 

Steps:-
* Drop the database and ingest data again
* Create the new model in core app
"
class User(AbstractUser):
    email = models.EmailField(unique=True)
"
* Add "AUTH_USER_MODEL = 'core.User'" in settings.py of storefront2 project directory.
* Change reference from default User model to our new User Model by using "settings.AUTH_USER_MODEL"
"
from django.conf import settings
from django.db import models
# from django.contrib.auth.models import User
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey

class LikedItem(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey()
"

#! Creating User Profiles
Make the following changes in the Customer Model:
"
class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold'),
    ]
    # first_name = models.CharField(max_length=255)
    # last_name = models.CharField(max_length=255)
    # email = models.EmailField(unique=True)
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True, blank=True)
    membership = models.CharField(
        max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    def __str__(self):
        return f'{self.user.first_name} {self.user.last_name}'
    
    @admin.display(ordering='user__first_name')
    def first_name(self):
        return self.user.first_name
    
    @admin.display(ordering='user__last_name')
    def last_name(self):
        return self.user.last_name

    class Meta:
        ordering = ['user__first_name', 'user__last_name']
"
and add the following changes in CustomerAdmin: 
"
@admin.register(models.Customer)
class CustomerAdmin(admin.ModelAdmin):
    list_display = ['first_name', 'last_name',  'membership', 'orders']
    list_editable = ['membership']
    list_per_page = 10
    list_select_related = ['user']
    ordering = ['user__first_name', 'user__last_name']
    search_fields = ['first_name__istartswith', 'last_name__istartswith']
"

#! Groups and Permissions
1. Rather than handling each user individually, we can add them to a group and assign permissions to them.
2. Then go to any particular user and assign that user to a group.
3. Now login using that user's credentials and you will see that that user has access to only the models which are in that group with certain permissions.

#! Creating Custom Permissions
1. We can also add permissions in our models directly.
"
class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)
    customer = models.ForeignKey(Customer, on_delete=models.PROTECT)
    
    class Meta:
        permissions = [
            ('cancel_order', 'Can cancel order')
        ]
"

#* Section - 6 (Securing APIs)
* Token-based authentication
* Adding authentication endpoints
* Registering, logging in, etc.
* Applying permissions

#! Token based authentication
* Let's say the user wants to go to "http://localhost:8000/api/products/", then another request will be sent to "http://localhost:8000/api/auth/" with will check the username and passsword of that user, if that is correct then a token will be returned. Using that token, the user can make any other request to the API.

#! Adding the Authentication Endpoints 
* We know that django comes with an fully-fledged authentication system but this system does not include any api layer i.e endpoints for the user to login, register, etc. We only have a bunch of models, database tables, etc. Now we can build this layer by hand but it will be difficult to maintain it and repetitive.
* Instead we will use DJOSER package to add authentication endpoints. It provides views for user registration, login, logout, etc.
#TODO -> "https://djoser.readthedocs.io/en/latest/index.html"
* pip install -U djoser
* Add 'djoser' in INSTALLED_APPS in settings.py
* Add 'path('auth/', include('djoser.urls')),' to urls.py of the project directory.
Now to implement AUTH ENGINES, we have 2 choices:
a) Token-based authentication which stores token in the database and validates token in every request. This sends request to the backend everytime to validate the token.
b) JSON Web Token authentication which stores a digital signature as token in the browser and validates token in every request. This sends request to the backend only when the token is valid.
* We will use JSON Web Token authentication in our project.
* pip install -U djangorestframework_simplejwt
* Add the following code in settings.py
"
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
}

SIMPLE_JWT = {
   'AUTH_HEADER_TYPES': ('JWT',),
}
"

Available endpoints:
    /users/
    /users/me/
    /users/confirm/
    /users/resend_activation/
    /users/set_password/
    /users/reset_password/
    /users/reset_password_confirm/
    /users/set_username/
    /users/reset_username/
    /users/reset_username_confirm/

    /token/login/ (Token Based Authentication)
    /token/logout/ (Token Based Authentication)
    /jwt/create/ (JSON Web Token Authentication)
    /jwt/refresh/ (JSON Web Token Authentication)
    /jwt/verify/ (JSON Web Token Authentication)

#! Registering Users
When you go to "http://127.0.0.1:8000/auth/users/", we get
"
HTTP 401 Unauthorized
Allow: GET, POST, HEAD, OPTIONS
Content-Type: application/json
Vary: Accept
WWW-Authenticate: JWT realm="api"

{
    "detail": "Authentication credentials were not provided."
}
"
Here we can see that it accepts POST request, so we can register a new user.
When I send post request with body
"
{
    "email": "user1@domain.com",
    "username": "user1",
    "password": "1234"
}
"
I get 400 Bad request
"
HTTP 400 Bad Request
Allow: GET, POST, HEAD, OPTIONS
Content-Type: application/json
Vary: Accept

{
    "password": [
        "This password is too short. It must contain at least 8 characters.",
        "This password is too common.",
        "This password is entirely numeric."
    ]
}
"
So provide a good password and a new user wwill be registered.

#TODO -> How to send first_name and last_name in POST request?
Ans) We need to have a custom serializer to send the first_name and last_name in POST request.

#TODO -> Refer => "https://djoser.readthedocs.io/en/latest/settings.html#serializers"
#TODO -> Refer => "https://stackoverflow.com/questions/49095424/customize-the-djoser-create-user-endpoint"

#? These are the default serializers provided by djoser
"
{
    'activation': 'djoser.serializers.ActivationSerializer',
    'password_reset': 'djoser.serializers.SendEmailResetSerializer',
    'password_reset_confirm': 'djoser.serializers.PasswordResetConfirmSerializer',
    'password_reset_confirm_retype': 'djoser.serializers.PasswordResetConfirmRetypeSerializer',
    'set_password': 'djoser.serializers.SetPasswordSerializer',
    'set_password_retype': 'djoser.serializers.SetPasswordRetypeSerializer',
    'set_username': 'djoser.serializers.SetUsernameSerializer',
    'set_username_retype': 'djoser.serializers.SetUsernameRetypeSerializer',
    'username_reset': 'djoser.serializers.SendEmailResetSerializer',
    'username_reset_confirm': 'djoser.serializers.UsernameResetConfirmSerializer',
    'username_reset_confirm_retype': 'djoser.serializers.UsernameResetConfirmRetypeSerializer',
    'user_create': 'djoser.serializers.UserCreateSerializer',
    'user_create_password_retype': 'djoser.serializers.UserCreatePasswordRetypeSerializer',
    'user_delete': 'djoser.serializers.UserDeleteSerializer',
    'user': 'djoser.serializers.UserSerializer',
    'current_user': 'djoser.serializers.UserSerializer',
    'token': 'djoser.serializers.TokenSerializer',
    'token_create': 'djoser.serializers.TokenCreateSerializer',
}
"

* Step-1: Create a custom serializer in serializers.py from core app
"
from djoser.serializers import UserCreateSerializer as BaseUserCreateSerializer


class UserCreateSerializer(BaseUserCreateSerializer):
    class Meta(BaseUserCreateSerializer.Meta):
        fields = ["id", "username", "password", "email", "first_name", "last_name"]

"
* Step-2: Add the custom serializer in settings.py of the project i.e storefront2
"
DJOSER = {
    'SERIALIZERS': {
        'user_create': 'core.serializers.UserCreateSerializer',  
    }
}
"
Now when you go to "http://127.0.0.1:8000/auth/users/", we get
"
{
    "username": "",
    "password": "",
    "email": "",
    "first_name": "",
    "last_name": ""
}
"

#! EACH COMPONENT SHOULD HAVE A SINGLE RESPONSIBILITY

#! Building the Profile API
DJOSER does not have a profile API, it just focuses on authentication. So we need to build it from scratch ourselves.
** serializer.py
"
class CustomerSerializer(serializers.ModelSerializer):
    #! We want user_id to also be present in the body of the request so declare it here
    user_id = serializers.IntegerField()
    class Meta:
        model = Customer
        #! Here we need user's id but that is a foreign key relation so we write user_id
        fields = ["id", "user_id", "phone", "birth_date", "membership"]
"

** views.py
"
#! Since we do not want to list all the customers, we will not use ModelViewSet but rather mixture of mixins and generic view set.
class CustomerViewSet(
    CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericViewSet
):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
"

** urls.py
"
router.register('customers', views.CustomerViewSet)
"

#! Logging in (Authenticating Users)
Go to "http://127.0.0.1:8000/auth/jwt/create/", we get
"
{
    "username": "",
    "password": ""
}
"
If you send wrong username or password, you will get an error but for correct username and password, you will get a refresh and access token.
"
{
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcxOTMzNTYwNywiaWF0IjoxNzE5MjQ5MjA3LCJqdGkiOiI3OTFjNjRhYjJiZTY0OGM5OTY4OTc0NTlhMmFjYTM0MCIsInVzZXJfaWQiOjN9.qQvi67f5bD6uQbJ_oVaVmAEx7gr7GHpbPISbCDJuqog",
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzE5MjQ5NTA3LCJpYXQiOjE3MTkyNDkyMDcsImp0aSI6IjlhMmUyMzMwNjE4YzQ4ZDE5ODkyYWQ0ZGNmNjIzMGM1IiwidXNlcl9pZCI6M30.i5o8QYoKRCOMmH5iPr5IIWJWd_c13Y81MoSNxDwwmXg"
}
"

* The access token is used to access the API.
* When the token is expired, we can refresh and get a new token using the refresh token.

* By default, the access token is valid for 5 minutes and the refresh token is valid for 1 day but we can easily overwrite these settings

#TODO -> "https://django-rest-framework-simplejwt.readthedocs.io/en/latest/index.html"
#TODO -> "https://django-rest-framework-simplejwt.readthedocs.io/en/latest/settings.html"

*You can change this by adding "ACCESS_TOKEN_LIFETIME" and "REFRESH_TOKEN_LIFETIME" in settings.py

* Add this to settings.py
"
SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(days=10), #! Now the access token is valid for 10 days
}
"

After sending a POST request to "auth/jwt/create/", we get
"
{
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcxOTMzNzI2NSwiaWF0IjoxNzE5MjUwODY1LCJqdGkiOiIyZTIxNTBjM2E2ZjI0MGU2OGQ0NTg1MjBlNjQ2MTQyNiIsInVzZXJfaWQiOjN9.lvA29ftKbxIkLckWCPaqpWPwhD8fRpZ4NcZajBqLnYE",
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzIwMTE0ODY1LCJpYXQiOjE3MTkyNTA4NjUsImp0aSI6IjYxZjMyMjdkYjQ0NDQ1N2I5NGY1MGQyMjM3OWI3NDg1IiwidXNlcl9pZCI6M30.i7yDMstftNKd1l2_VMtcTN7e_UentEn3aUIH_fnnyxo"
}
"
* When the user logs in successfully, we store the token in the local storage and to logout the user, just remove the token from the local storage.

#! Inspecting the JWT token
* Go to "https://jwt.io/" and paste your access and refresh token.

#! Refreshing the JWT token
* Go to "http://127.0.0.1:8000/auth/jwt/refresh/" and paste your refresh token. You will get a new access token.

#! Getting the current user
* Go to "http://127.0.0.1:8000/auth/users/me/", you will get:
"
HTTP 401 Unauthorized
Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS
Content-Type: application/json
Vary: Accept
WWW-Authenticate: JWT realm="api"

{
    "detail": "Authentication credentials were not provided."
}
"
* Install Modheader extension for Chrome, and set "Authorization: JWT <access token>" in the request header because we have used the following settings
"
SIMPLE_JWT = {
    'AUTH_HEADER_TYPES': ('JWT',),
    "ACCESS_TOKEN_LIFETIME": timedelta(days=10),
}
"
* After doing so go to "auth/users/me/" and you will get the user details
"
HTTP 200 OK
Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS
Content-Type: application/json
Vary: Accept

{
    "email": "user1@domain.com",
    "id": 3,
    "username": "user1"
}
"
* Now we want first_name and last_name in the response. So we will overwrite the default serializer to get the user details. To know which serializer to overwrite, go to "https://djoser.readthedocs.io/en/latest/settings.html"
"
{
    'activation': 'djoser.serializers.ActivationSerializer',
    'password_reset': 'djoser.serializers.SendEmailResetSerializer',
    'password_reset_confirm': 'djoser.serializers.PasswordResetConfirmSerializer',
    'password_reset_confirm_retype': 'djoser.serializers.PasswordResetConfirmRetypeSerializer',
    'set_password': 'djoser.serializers.SetPasswordSerializer',
    'set_password_retype': 'djoser.serializers.SetPasswordRetypeSerializer',
    'set_username': 'djoser.serializers.SetUsernameSerializer',
    'set_username_retype': 'djoser.serializers.SetUsernameRetypeSerializer',
    'username_reset': 'djoser.serializers.SendEmailResetSerializer',
    'username_reset_confirm': 'djoser.serializers.UsernameResetConfirmSerializer',
    'username_reset_confirm_retype': 'djoser.serializers.UsernameResetConfirmRetypeSerializer',
    'user_create': 'djoser.serializers.UserCreateSerializer',
    'user_create_password_retype': 'djoser.serializers.UserCreatePasswordRetypeSerializer',
    'user_delete': 'djoser.serializers.UserDeleteSerializer',
    'user': 'djoser.serializers.UserSerializer',
    'current_user': 'djoser.serializers.UserSerializer',
    'token': 'djoser.serializers.TokenSerializer',
    'token_create': 'djoser.serializers.TokenCreateSerializer',
}
"
* We can observe that the 'current_user' key has a certain serializer. We need to overwrite that.
* Step-1: Go to core.serializers and create a new serializer.
"
from djoser.serializers import UserCreateSerializer as BaseUserCreateSerializer, UserSerializer as BaseUserSerializer
from rest_framework import serializers


class UserCreateSerializer(BaseUserCreateSerializer):
    class Meta(BaseUserCreateSerializer.Meta):
        fields = ["id", "username", "password", "email", "first_name", "last_name"]


class UserSerializer(BaseUserSerializer):
    class Meta(BaseUserSerializer.Meta):
        fields = ["id", "username", "email", "first_name", "last_name"]
"
* Step-2: Register this serializer in the settings.py of the project i.e storefront2
"
DJOSER = {
    'SERIALIZERS': {
        'user_create': 'core.serializers.UserCreateSerializer',  
        'current_user': 'core.serializers.UserSerializer',
    }
}
"

#! Getting the current user's profile
We want a route "store/customers/me" which should give the current user's profile
For that, we need @actions decorators

** views
"
#! This is a demo action
class CustomerViewSet(
    CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericViewSet
):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer

    @action(detail=False)
    def me(self, request):
        return Response('Ok')
"

@action decorator and me method
The @action decorator allows you to add custom endpoints to your viewset. The me method in this viewset is a custom action.

detail=False: This means that this action does not operate on a single instance but rather on the entire collection like "store/customers/me". Typically, detail=True would be used for actions that act on a single object like "store/customers/1/me".

me method: This method is a custom endpoint that can be accessed via the URL pattern /customers/me/. Currently, it simply returns a response with the text 'Ok'.

** serializers.py (defined before)
"
class CustomerSerializer(serializers.ModelSerializer):
    #! We want user_id to also be present in the body of the request so declare it here
    user_id = serializers.IntegerField(read_only=True)
    class Meta:
        model = Customer
        #! Here we need user's id but that is a foreign key relation so we write user_id
        fields = ["id", "user_id", "phone", "birth_date", "membership"]
"
** views.py
"
#! Since we do not want to list all the customers, we will not use ModelViewSet but rather mixture of mixins and generic view set.
class CustomerViewSet(
    CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericViewSet
):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer

    #! If the user is authenticated, we will get USER instance else AnonymousUser instance
    @action(detail=False, methods=["GET", "PUT"])
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(user_id=request.user.id)
        if request.method == "GET":
            print(request.user)
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == "PUT":
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
"

#! Applying Django Permissions
* Use permission_classes in views or we can use decorators
** views.py
"
class CustomerViewSet(
    CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericViewSet
):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAuthenticated]
    
    #! Here we are overwriting the get_permissions() method according to the request method
    def get_permissions(self):
        if self.request.method == "GET":
            return [AllowAny()]
        return [IsAuthenticated()]

    #! If the user is authenticated, we will get USER instance else AnonymousUser instance
    @action(detail=False, methods=["GET", "PUT"])
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(user_id=request.user.id)
        if request.method == "GET":
            print(request.user)
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == "PUT":
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
"
* We can also add DEFAULT_PERMISSION_CLASSES in settings.py for setting global permissions.

#! Creating Custom Permissions
* Go to "https://www.django-rest-framework.org/api-guide/permissions/"
* We see that there is no API reference named "IsAdminOrReadOnly" so we will create one.
* Create a permissions.py in store app
"
from rest_framework import permissions


class IsAdminOrReadOnly(permissions.BasePermission):
    def has_permission(self, request, view):
        if request.method in permissions.SAFE_METHODS:
            return True
        return bool(request.user and request.user.is_staff)

"
* Now apply these permissions in required viewsets present in views.py

#! Applying Model Permissions
* Create a permission in permissions.py
"
class FullDjangoModelPermissions(permissions.DjangoModelPermissions):
    def __init__(self):
        self.perms_map["GET"] = ["%(app_label)s.view_%(model_name)s"]
"


#! Applying Custom Model Permissions
* Check Permissions from Meta class of Model

** models.py
"
class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold'),
    ]
    # first_name = models.CharField(max_length=255)
    # last_name = models.CharField(max_length=255)
    # email = models.EmailField(unique=True)
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True, blank=True)
    membership = models.CharField(
        max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    def __str__(self):
        return f'{self.user.first_name} {self.user.last_name}'
    
    @admin.display(ordering='user__first_name')
    def first_name(self):
        return self.user.first_name
    
    @admin.display(ordering='user__last_name')
    def last_name(self):
        return self.user.last_name

    class Meta:
        ordering = ['user__first_name', 'user__last_name']
        permissions = [
            ('view_history', 'Can View History'),
        ]
"

** permissions.py
"
class ViewCustomerHistoryPermission(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user.has_perm('store.view_history')
"

** views.py
"
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAdminUser]
    
    @action(detail=True, permission_classes=[ViewCustomerHistoryPermission])
    def history(self, request, pk):
        return Response("OK")

    #! If the user is authenticated, we will get USER instance else AnonymousUser instance
    @action(detail=False, methods=["GET", "PUT"], permission_classes=[IsAuthenticated])
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(user_id=request.user.id)
        if request.method == "GET":
            print(request.user)
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == "PUT":
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
"

#* Section - 7 (Building the Orders API)

#! Designing the Orders API
* Method
* url endpoints
* request body
* response body

a) Orders Endpoint
* Method - POST
* url endpoint - /store/orders/
* request body - {cartId}
* response body - order object

* Method - GET
* url endpoint - /store/orders/
* request body - None
* response body - order object

* Method - GET
* url endpoint - /store/orders/{id}/
* request body - None
* response body - order object for that order id

* Method - PATCH
* url endpoint - /store/orders/{id}/
* request body - updated data
* response body - order object for that order id

* Method - DELETE
* url endpoint - /store/orders/{id}/
* request body - None
* response body - None

#! Getting the Orders
Step-1 (already completed)
* Create a Orders model
* Run makemigrations
* Migrate

Step-2
* Create a Serializer
* Create a view
* Register a route

** models.py
"
class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)
    customer = models.ForeignKey(Customer, on_delete=models.PROTECT)
    
    class Meta:
        permissions = [
            ('cancel_order', 'Can cancel order')
        ]


class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.PROTECT, related_name="items")
    product = models.ForeignKey(Product, on_delete=models.PROTECT, related_name='orderitems')
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6, decimal_places=2)
"

** serializer.py
"
class  OrderItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer()
    class Meta:
        model = OrderItem
        fields = ["id", "product", "unit_price", "quantity"]
        
class OrderSerializer(serializers.ModelSerializer):
    items = OrderItemSerializer(many=True)
    class Meta:
        model = Order
        fields = ["id", "customer", "placed_at", "payment_status", "items"]
"

** views.py
"
class OrderViewSet(ModelViewSet):
    queryset = Order.objects.all()
    serializer_class = OrderSerializer
"

** urls.py
"
router.register('orders', views.OrderViewSet)
"

#! Applying Permissions
** views.py
"
class OrderViewSet(ModelViewSet):
    # queryset = Order.objects.all()
    serializer_class = OrderSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        user = self.request.user
        
        if user.is_staff:
            return Order.objects.all()
         
        (customer_id, created) = Customer.objects.only("id").get_or_create(user_id=user.id)
        return Order.objects.filter(customer_id=customer_id)
"

** urls.py
"
router.register('orders', views.OrderViewSet, basename='orders')
"

#! Creating an Order
* Since for POST request, we will only send CartId, we can not use ModelSerializer
* Create a new serializer but without using ModelSerializer, we will use Serializer
#? Just try to think logically, first we will send the cartId, then the order of the logged in user should be placed/created. The logged in user is the customer.
** serializers.py
"
class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()
    
    def save(self, **kwargs):
        print(self.validated_data['cart_id'])
        #! Since this is a serializer, we cannot access self.request here, so we will do so and get the user_id from the view itself
        print(self.context["user_id"])
        
        (customer,created) = Customer.objects.get_or_create(user_id=self.context["user_id"])
        
        Order.objects.create(customer=customer)
"

** views.py
"
class OrderViewSet(ModelViewSet):
    # queryset = Order.objects.all()
    # serializer_class = OrderSerializer
    permission_classes = [IsAuthenticated]
    
    def get_serializer_class(self):
        if self.request.method == "POST":
            return CreateOrderSerializer
        return OrderSerializer
        
    
    def get_serializer_context(self):
        return {'user_id': self.request.user.id}
    
    def get_queryset(self):
        user = self.request.user
        
        if user.is_staff:
            return Order.objects.all()
         
        (customer_id, created) = Customer.objects.only("id").get_or_create(user_id=user.id)
        return Order.objects.filter(customer_id=customer_id)
"

#! Creating Order Items
** serializers.py
"
class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()

    def save(self, **kwargs):
        with transaction.atomic():
            print(self.validated_data["cart_id"])
            #! Since this is a serializer, we cannot access self.request here, so we will do so and get the user_id from the view itself
            print(self.context["user_id"])
            
            cart_id = self.validated_data["cart_id"]
            # Here get the customer which matches the user_id, or create one if it doesn't exist
            (customer, created) = Customer.objects.get_or_create(user_id=self.context["user_id"])
            
            # Now get the items present in the cart
            cart_items = CartItem.objects.select_related("product").filter(cart_id=cart_id)
            
            # Now for that customer, place the order (DIM Table)
            order = Order.objects.create(customer=customer)
            
            # Get the order items to place in the order from the cart. OrderItem (Fact Table)
            order_items = [
                OrderItem(
                    order=order,
                    product=item.product,
                    unit_price=item.product.unit_price,
                    quantity=item.quantity,
                )
                for item in cart_items
            ]
            print("order_items", order_items)
            # Bulk create the order items
            OrderItem.objects.bulk_create(order_items)
            # After creating the order, delete the cart
            Cart.objects.filter(pk=cart_id).delete()
"

#! Returning the Order Object
* When we go to "store/orders/" and post a cart_id, we get the cart_id as response whereas we want the order object
* So we will overwrite the create method from the CreateModelMixin used in ModelViewSet
** serializers.py
"
class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()

    def save(self, **kwargs):
        with transaction.atomic():
            print(self.validated_data["cart_id"])
            #! Since this is a serializer, we cannot access self.request here, so we will do so and get the user_id from the view itself
            print(self.context["user_id"])
            
            cart_id = self.validated_data["cart_id"]
            # Here get the customer which matches the user_id, or create one if it doesn't exist
            (customer, created) = Customer.objects.get_or_create(user_id=self.context["user_id"])
            
            # Now get the items present in the cart
            cart_items = CartItem.objects.select_related("product").filter(cart_id=cart_id)
            
            # Now for that customer, place the order (DIM Table)
            order = Order.objects.create(customer=customer)
            
            # Get the order items to place in the order from the cart. OrderItem (Fact Table)
            order_items = [
                OrderItem(
                    order=order,
                    product=item.product,
                    unit_price=item.product.unit_price,
                    quantity=item.quantity,
                )
                for item in cart_items
            ]
            print("order_items", order_items)
            # Bulk create the order items
            OrderItem.objects.bulk_create(order_items)
            # After creating the order, delete the cart
            Cart.objects.filter(pk=cart_id).delete()
            return order
"

** views.py
"
class OrderViewSet(ModelViewSet):
    # queryset = Order.objects.all()
    # serializer_class = OrderSerializer
    permission_classes = [IsAuthenticated]
    
    #! Here we are overwriting the creatte method from the create model mixin
    def create(self, request, *args, **kwargs):
        serializer = CreateOrderSerializer(data=request.data, context={"user_id": request.user.id}) 
        serializer.is_valid(raise_exception=True)
        order = serializer.save()
        serializer = OrderSerializer(order)
        return Response(serializer.data)
    
    def get_serializer_class(self):
        if self.request.method == "POST":
            return CreateOrderSerializer
        return OrderSerializer
        
    
    # def get_serializer_context(self):
    #     return {'user_id': self.request.user.id}
    
    def get_queryset(self):
        user = self.request.user
        
        if user.is_staff:
            return Order.objects.all()
         
        (customer_id, created) = Customer.objects.only("id").get_or_create(user_id=user.id)
        return Order.objects.filter(customer_id=customer_id)
"

#! Data Validation
* Whenever we create a new order using the cart_id, a order always gets created even when there are no items in the cart.
* To fix this, we need to add validation for cart_id
* Add this to CreateOrderSerializer
"
def validate_cart_id(self, cart_id):
        #! If the user is using any old cart_id which is already deleted from the database, we will raise an error
        if not Cart.objects.filter(pk=cart_id).exists():
            raise serializers.ValidationError('No cart with the given ID was found.')
        #! If the cart is empty, we will raise an error
        if CartItem.objects.filter(cart_id=cart_id).count() == 0:
            raise serializers.ValidationError('The cart is empty.')
        return cart_id
"

#! Revisiting Permissions for the OrderViewSet
* Now only the admin can do CRUD operations and the authenticated user can only do read operations
** views.py
"
class OrderViewSet(ModelViewSet):
    # queryset = Order.objects.all()
    # serializer_class = OrderSerializer
    # permission_classes = [IsAuthenticated]
    
    http_method_names = ["get", "patch", "delete", 'head', 'options']
    def  get_permissions(self):
        if self.request.method in ['PATCH', 'DELETE']:
            return [IsAdminUser()]
        return [IsAuthenticated()]
    
    #! Here we are overwriting the creatte method from the create model mixin
    def create(self, request, *args, **kwargs):
        serializer = CreateOrderSerializer(data=request.data, context={"user_id": request.user.id}) 
        serializer.is_valid(raise_exception=True)
        order = serializer.save()
        serializer = OrderSerializer(order)
        return Response(serializer.data)
    
    def get_serializer_class(self):
        if self.request.method == "POST":
            return CreateOrderSerializer
        return OrderSerializer
        
    
    # def get_serializer_context(self):
    #     return {'user_id': self.request.user.id}
    
    def get_queryset(self):
        user = self.request.user
        
        if user.is_staff:
            return Order.objects.all()
         
        (customer_id, created) = Customer.objects.only("id").get_or_create(user_id=user.id)
        return Order.objects.filter(customer_id=customer_id)
"

#! Updating the Order
** serializers.py
"
class UpdateOrderSerializer(serializers.ModelSerializer):
    class Meta:
        model = Order
        fields = ['payment_status']
"

** views.py (Add PATCH condition in the get_serializer_class of OrderViewSet)
"
def get_serializer_class(self):
        if self.request.method == "POST":
            return CreateOrderSerializer
        elif self.request.method == "PATCH":
            return UpdateOrderSerializer
        return OrderSerializer
"

#! Signals
* Django signals are a powerful feature that allows decoupled applications to get notified when certain actions occur elsewhere in the application. They provide a way to perform operations in response to events. This is especially useful for triggering functions to run automatically after certain actions, such as saving a model instance or sending an email when a new user registers.
* Django provides several built-in signals, such as pre_save, post_save, pre_delete, post_delete, m2m_changed, etc.

Now we want that when a user is created, a customer should be created as well. Right now we were using get_or_create as a hack but this is not a correct approach as we were creating dummy customer if it did not exist.

To solve this, we will use signals and create a customer as soon as the user is created.

* Create a signals.py in the store app
** signals.py
"
from django.conf import settings
from django.db.models.signals import post_save
from django.dispatch import receiver
from store.models import Customer

@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_customer_for_new_user(sender, **kwargs):
    if kwargs['created']:
        Customer.objects.create(user=kwargs['instance'])
"
* Now add this to apps.py of the store app
** apps.py
"
from django.apps import AppConfig


class StoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'store'

    def ready(self) -> None:
        import store.signals
"
* Now replace get_or_create with just get in all the implementations

#! Using Custom Signals
* Created a signals folder and moved the signals.py inside it.
* Renamed the signals.py to handlers.py and we defined handlers inside the file
* Implemented it for store and core app

-------------------------------------------------------------------------THE END-------------------------------------------------------------------------